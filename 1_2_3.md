Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 1. Концепции баз данных

**ВВЕДЕНИЕ**

**Основные понятия**

База данных (БД) представляет собой совокупность специальным образом организованных данных, хранимых в памяти вычислительной системы и отображающих состояние объектов и их взаимосвязей в рассматриваемой предметной области.

Предметная область – часть реального мира, подлежащая изучению.

Система управления базами данных (СУБД) – это комплекс языковых и программных средств, предназначенный для создания, ведения и совместного использования БД многими пользователями.

**Логическая модель данных**

БД можно представить как совокупность информации, организованной в виде множеств. Каждое множество содержит записи унифицированного вида. Записи состоят из полей.

Множества называют таблицами, а записи – строками таблиц. Строки таблиц связаны друг с другом.


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ВВЕДЕНИЕ**

**Способы связи строк**

- Отношение – «один к одному» ( **1:1** )
- Отношение – «один ко многим» ( **1:N** )
- Отношение – «многие ко многим» ( **N:M** )

Логическую структуру хранимых в базе данных называют моделью представления данных.

**Основные модели представления данных**

- Иерархическая,
- Сетевая,
- Реляционная,
- Постреляционная,
- Многомерная,
- Объектно-ориентированная,
- Объектно-реляционная.

**ИЕРАРХИЧЕСКИЕ БАЗЫ ДАННЫХ**

Иерархические базы данных поддерживают древовидную организацию информации. Для описания структуры  ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.004.jpeg)(схемы) иерархической БД на некотором языке программирования используется тип данных «дерево». 

*Ориентированным деревом называется бесконтурный ориентированный граф у которого полустепень захода  (число входящих рёбер) любой вершины не больше 1 и существует ровно одна вершина, называемая корнем  ориентированного дерева, полустепень захода которой равна 0.* 

Графически отношения изображают дугами ориентированного графа, типы записей – вершинами (диаграмма  Бахмана). 

Связи между записями выражаются в виде отношений предок/потомок. 

Вершина **V** ориентированного дерева называют потомком вершины **U** если существует путь ненулевой длины из **U** в **V**. Вершина **U** называется предком вершины **V**.

У каждой записи есть ровно одна родительская запись. Это помогает поддерживать ссылочную целостность. Когда запись удаляется из дерева, все ее потомки также должны быть удалены.

**ИЕРАРХИЧЕСКИЕ БАЗЫ ДАННЫХ**

**Пример: модель данных предприятия**

Предприятие состоит из отделов, в которых работают сотрудники. В каждом отделе может работать несколько сотрудников, сотрудник не может работать более чем в одном отделе. Для информационной системы управления персоналом необходимо создать отношение, состоящее из родительской записи

**ОТДЕЛ (НАЗВАНИЕ\_ОТДЕЛА, КОЛИЧЕСТВО\_СОТРУДНИКОВ)** и дочерней записи

**СОТРУДНИК (ФАМИЛИЯ, ДОЛЖНОСТЬ, ОКЛАД)**

Для автоматизации учета контрактов с заказчиками необходимо создать еще две иерархические структуры: заказчик – контракты – исполнители (сотрудники задействованные в работе над контрактом) и исполнитель – контракт (если исполнитель принимает участие более чем в одном контракте)

**ЗАКАЗЧИК (НАЗВАНИЕ\_ЗАКАЗЧИКА, АДРЕС), КОНТРАКТ (НОМЕР, ДАТА, СУММА),**

**ИСПОЛНИТЕЛЬ (ФАМИЛИЯ, ДОЛЖНОСТЬ, НАЗВАНИЕ\_ОТДЕЛА)**

**ИЕРАРХИЧЕСКИЕ БАЗЫ ДАННЫХ**

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.005.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.006.png)

**ИЕРАРХИЧЕСКИЕ БАЗЫ ДАННЫХ**

**Пример: модель данных предприятия**

Из примера видны **недостатки** иерархических БД:

1) Частично дублируется информация между записями СОТРУДНИК и ИСПОЛНИТЕЛЬ (такие записи называют парными, поддержка соответствия между ними не предусмотрена).
1) Иерархическая модель реализует отношение между исходной и дочерней записью по схеме **1:N**, то есть одной родительской записи может соответствовать любое число дочерних.

Если исполнитель принимает участие более чем в одном контракте (т.е. возникает связь типа **N:M**), в базу данных необходимо ввести еще одно групповое отношение, в котором ИСПОЛНИТЕЛЬ будет являться исходной записью, а КОНТРАКТ – дочерней. Происходит дублирование информации.

**СЕТЕВЫЕ БАЗЫ ДАННЫХ**

*Ориентированной сетью (или просто сетью) называют бесконтурный ориентированный граф.*

Основные принципы сетевой модели данных были разработаны в середине 60-х годов (Ч. Бахман), эталонный вариант описан в отчетах рабочей группы по языкам баз данных (COnference on DAta System Languages) CODASYL (1971г.).

Для описания схемы сетевой БД используется две группы типов: «запись» и «связь». Тип «связь» определяется для двух типов «запись»: предка и потомка.

В сетевой модели допускаются отношения «многие ко многим». Записи не зависят друг от друга. При удалении записи удаляются и все ее связи, но не сами связанные записи.

Примеры сетевых БД: ADABAS, IDMS (Cullinet), Total (Cincom)

**СЕТЕВЫЕ БАЗЫ ДАННЫХ**

**Достоинства** сетевой модели данных:

- Возможность эффективной реализации по показателям затрат памяти и оперативности.
- В сравнении с иерархической моделью сетевая модель предоставляет большие возможности в смысле допустимости образования произвольных связей.
- Программисту не нужно заботиться о том, как организуется физическое хранение данных на диске. Это ослабляет *зависимость приложений и данных*.
- Стандартизация (стандарт CODASYL).

**Недостатки** сетевой модели данных:

- Высокая сложность и жесткость схемы БД, построенной на ее основе.
- Сложность для понимания и выполнения обработки информации в БД обычным пользователем.
- Ослаблен контроль целостности связей вследствие допустимости установления произвольных связей между записями.
- Оптимальную структуру базы данных сложно сформировать, готовую структуру трудно менять.
- При изменении вида таблицы, все отношения с другими таблицами должны быть установлены заново, чтобы не нарушилась **целостность данных**.

*Под целостностью данных понимают: при модификации таблиц не должны быть потеряны сами данные и логические связи между ними; указанный тип и диапазон данных должен соблюдаться при любых изменениях. Задача сложная, программисты часто отменяют некоторые ограничения целостности ради упрощения приложений.*

**СЕТЕВЫЕ БАЗЫ ДАННЫХ**

Преобразование **иерархической структуры** в **сетевую**: ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.007.png)

- Деревья заменяются одной сетевой структурой. 
- Для отображения типа **N:M** вводится запись  СОТРУДНИК\_КОНТРАКТ, не имеющая полей, для связи записей  КОНТРАКТ и СОТРУДНИК. 

**РЕЛЯЦИОННЫЕ БАЗЫ ДАННЫХ**

**Реляционная модель данных** – разработанная Э. Коддом в 1970г. логическая модель данных основанная на математической теории отношений.

Эдгар Франк Кодд (23 августа 1923 – 18 апреля 2003) – британский математик, работы которого заложили основы теории реляционных баз данных. Работая в компании IBM, он создал реляционную модель данных.

**Отношение** (relation) представляет собой множество элементов, называемых кортежами. Наглядной формой представления отношения является двумерная таблица. Таблица имеет строки (записи) и столбцы (колонки). Каждая строка таблицы имеет одинаковую структуру и состоит из полей. Строкам таблицы соответствуют кортежи, а столбцам – атрибуты отношения.

«Изначально ... реляционная модель ... рассматривалась как средство для освобождения пользователей от неприятностей, связанных с потребностью иметь дело с массой деталей представления хранимых данных»

Кодд сформулировал «принципиальные мотивы создания реляционной модели»:

- Независимость данных.
- Простейшая из числа возможных структура, согласованная с семантическими соображениями.
- Обеспечение унифицирующего принципа, упрощающего язык, требуемый для взаимодействия, и анализ операций, требуемый для авторизации доступа и оптимизации поиска.
- Сравнительно легкий анализ согласованности данных.

**РЕЛЯЦИОННЫЕ БАЗЫ ДАННЫХ**

В сравнении с рассмотренными ранее моделями, реляционная модель требует от СУБД гораздо более высокого уровня сложности. В реляционной модели база данных представляет собой централизованное хранилище таблиц, обеспечивающее безопасный одновременный доступ к информации со стороны многих пользователей. Таблицы содержат данные относящиеся непосредственно к записи и ссылки на строки других таблиц. Связи между записями являются неотъемлемым свойством реляционной модели. Каждая строка таблицы имеет одинаковую структуру. Такие таблицы легко изображать в графическом виде. В реляционной модели достигается информационная и структурная независимость.

**Реляционная модель данных** описывает:

- структуры данных в виде (изменяющихся во времени) наборов отношений;
- теоретико-множественные операции над данными: объединение, пересечение, разность и декартово произведение;
- специальные реляционные операции: селекция, проекция, соединение и деление;
- специальные правила, обеспечивающие целостность данных.

**Языки запросов** можно отнести к двум классам:

1) алгебраические языки, позволяющие выражать запросы средствами специализированных операторов, применяемых к отношениям;
1) языки исчисления предикатов, представляющие собой набор правил для записи выражения, определяющего новое отношение.

**РЕЛЯЦИОННЫЕ БАЗЫ ДАННЫХ**

В реляционных СУБД применяется язык **SQL**, позволяющий формировать произвольные, нерегламентированные запросы. Это язык четвертого поколения, непроцедурный язык, т.е. говорит, что надо делать, а не как.

**Достоинство** реляционной модели данных заключается в простоте, понятности и удобстве физической реализации на ЭВМ. Это явилось основной причиной их широкого использования.

**Недостатками** реляционной модели являются: отсутствие стандартных средств идентификации отдельных записей; сложность описания иерархических и сетевых связей.

**РЕЛЯЦИОННЫЕ БАЗЫ ДАННЫХ**

**Клиент-серверная архитектура**

Большинство реляционных СУБД функционируют по модели **«клиент-сервер»**.

**Сервером** определенного ресурса в компьютерной сети называется компьютер (программа), управляющий этим ресурсом, клиентом – компьютер (программа), использующий этот ресурс.

Достоинством организации ИС по архитектуре клиент-сервер является сочетание централизованного хранения, обслуживания и коллективного доступа к общей корпоративной информации с индивидуальной работой пользователей над персональной информацией.

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.008.png)

**ПОСТРЕЛЯЦИОННАЯ МОДЕЛЬ**

Классическая реляционная модель предполагает неделимость данных, хранящихся в полях записей таблиц. Существует ряд случаев, когда это ограничение мешает эффективной реализации приложений.

**Постреляционная модель** данных представляет собой расширенную реляционную модель, снимающую ограничение неделимости данных, хранящихся в записях таблиц. Постреляционная модель данных допускает многозначные поля – поля, значения которых состоят из подзначений. Набор значений многозначных полей считается самостоятельной таблицей, встроенной в основную таблицу.

Для обеспечения целостности данных приходится создавать процедуры, автоматически вызываемые до или после обращения к данным.

**Достоинством** постреляционной модели является возможность представления совокупности связанных реляционных таблиц одной постреляционной таблицей. Это обеспечивает высокую наглядность представления информации и повышение эффективности ее обработки.

**Недостатком** постреляционной модели является сложность решения проблемы обеспечения целостности и непротиворечивости хранимых данных.

**ПОСТРЕЛЯЦИОННАЯ МОДЕЛЬ**

**Пример: информация об объектах (накладные и товары) представлена с помощью реляционной и постреляционной моделей**

Таблица **накладные** (INVOICES) содержит номера накладных (INV\_N) и номерах покупателей (CUST\_N).

Таблица **накладные-товары** (INVOICES-GOODS) содержит данные о каждой из накладных: INV\_N, название товара (GOODS) и количество товара (QTY).

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.009.png) ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.010.png)

**МНОГОМЕРНАЯ МОДЕЛЬ**

Многомерный подход к представлению данных в базе появился практически одновременно с реляционным. Многомерные системы позволяют оперативно обрабатывать информацию для проведения анализа и принятия решения. Интерес к МСУБД после выхода в 1993 году программной статьи «12 законов аналитической обработки в реальном времени» одного из основоположников реляционного подхода Э. Кодда.

Коддом был предложен термин OLAP (Online Analytical Processing – оперативная аналитическая обработка). Работа Кодда финансировалась Arbor, компанией, выпустившей свой собственный OLAP-продукт – Essbase (теперь принадлежит Oracle). В статье сформулированы 12 основных требований к системам класса OLAP, важнейшие из которых связаны с возможностями концептуального представления и обработки многомерных данных.

В развитии концепций ИС можно выделить следующие два направления:

1. системы оперативной (транзакционной) обработки;
1. системы аналитической обработки (системы поддержки принятия решений), например, поиск в БД документов, в которых имеется вхождение заданной фразы в определенном контексте.

Реляционные СУБД предназначались для информационных систем оперативной обработки информации и в этой области были весьма эффективны. В системах аналитической обработки они показали себя несколько неповоротливыми и недостаточно гибкими.

**МНОГОМЕРНАЯ МОДЕЛЬ**

**Многомерные СУБД** являются узкоспециализированными СУБД, предназначенными для интерактивной аналитической обработки информации. Основные понятия, используемые в многомерных СУБД: агрегируемость, историчность и прогнозируемость данных.

**Агрегируемость** данных означает рассмотрение информации на различных уровнях ее обобщения. В ИС степень детальности представления информации зависит от уровня пользователя: пользователь-оператор, аналитик, управляющий, руководитель.

**Историчность** данных предполагает обеспечение высокого уровня статичности (неизменности) собственно данных и их взаимосвязей, а также обязательность привязки данных ко времени.

**Прогнозируемость** данных подразумевает задание функций прогнозирования и применение их к различным временным интервалам.

Многомерность модели данных означает не многомерность визуализации цифровых данных (*n*-мерные гиперкубы), а многомерное логическое представление структуры информации при описании и в операциях манипулирования данными.

С формальной точки зрения мы имеем дело с *n*-арным отношением  , ⊆ 1 × 2 × ⋯× , где  -конечное множество, характеризующее признак.

При многомерной модели с мерностью больше двух, визуально информация представляется в виде двухмерных таблиц или графиками. Данные при этом представляют собой «срезы» из многомерного хранилища данных, выполненные с разной степенью детализации.

**МНОГОМЕРНАЯ МОДЕЛЬ**

**Пример: данные об объемах продаж автомобилей**

По сравнению с реляционной моделью многомерная организация данных обладает более высокой наглядностью и информативностью.



|**Модель**|**Месяц**|**Объем**|
| - | - | - |
|Калина|Апрель|10|
|Калина|Май|15|
|Калина|Июнь|4|
|Focus|Апрель|10|
|Focus|Июнь|18|
|Cruze|Июнь|20|

|**Модель**|**Апрель**|**Май**|**Июнь**|
| - | - | - | - |
|Калина|10|15|4|
|Focus|10|N|18|
|Cruze|N|N|20|
**МНОГОМЕРНАЯ МОДЕЛЬ**

**Достоинством** многомерной модели данных является удобство и эффективность аналитической обработки больших объемов данных, связанных со временем. При организации обработки аналогичных данных на основе реляционной модели происходит нелинейный рост трудоемкости операций в зависимости от размерности БД и существенное увеличение затрат оперативной памяти на индексацию.

**Недостатком** многомерной модели данных является ее громоздкость для простейших задач обычной оперативной обработки информации.

**ОБЪЕКТНО-ОРИЕНТИРОВАННАЯ МОДЕЛЬ**

Объектно-ориентированная база данных (ООБД) позволяет программистам, которые работают с языками третьего поколения, интерпретировать все свои информационные сущности как **объекты**, хранящиеся в оперативной памяти. 

Дополнительный интерфейсный уровень абстракции обеспечивает перехват запросов, обращающихся к тем частям базы данных, которые находятся в постоянном хранилище на диске. Изменения, вносимые в объекты, оптимальным образом переносятся из памяти на диск. 

Преимуществом ООБД является упрощенный код. Данные в ООБД способны принять вид любой структуры, которую можно выразить на используемом языке программирования.

Сложные информационные структуры выражаются в ООБД лучше, чем в реляционных базах данных, устраняется необходимость транслировать данные из того формата, в котором они хранятся в формат поддерживаемый СУБД.

Объектно-ориентированные СУБД выполняют много дополнительных функций. Это окупается сполна, если отношения между данными очень сложны.

В объектно-ориентированной модели при представлении данных имеется возможность *идентифицировать отдельные записи* базы. Между записями БД и функциями их обработки устанавливаются взаимосвязи с помощью механизмов, подобных соответствующим средствам в объектно-ориентированных языках программирования.

**ОБЪЕКТНО-ОРИЕНТИРОВАННАЯ МОДЕЛЬ**

Большим **недостатком** объектно-ориентированных баз данных является их тесная связь с применяемым языком программирования и, как следствие, высокая понятийная сложность, неудобство обработки данных и низкая скорость выполнения запросов. Стандартизованная объектно-ориентированной модель описана в рекомендациях стандарта ODMG 3.0 (Object Database Management Group).

Структура объектно-ориентированной БД графически представима в виде дерева, узлами которого являются объекты, т.е. внешне похожа на структуру иерархической БД. Основное отличие между ними состоит в методах манипулирования данными. Свойства объектов описываются некоторым стандартным типом.

Для выполнения действий над данными в объектно-ориентированной модели БД применяются логические операции, используются такие механизмы ООП, как инкапсуляция, наследование и полиморфизм. Могут применяться операции, подобные командам SQL (например, для создания БД).

Создание и модификация БД сопровождается автоматическим формированием и последующей корректировкой индексов (для быстрого поиска данных). **Инкапсуляция** ограничивает область видимости имени свойства пределами того объекта, в котором оно определено.

**Наследование**, наоборот, распространяет область видимости свойства на всех потомков объекта.

**Полиморфизм** в объектно-ориентированных языках программирования означает способность одного и того же программного кода работать с разнотипными данными.

**ОБЪЕКТНО-РЕЛЯЦИОННЫЕ БАЗЫ ДАННЫХ**

Объектно-реляционные СУБД объединяют в себе черты реляционной и объектной моделей. Реляционные базы данных хорошо работают со встроенными типами данных и гораздо хуже – с пользовательскими, нестандартными. Для работы с новыми типами данных, надо или включать его поддержку в СУБД, или писать программы для управления данными в приложении.

Например, не всякую информацию имеет смысл интерпретировать в виде цепочек символов или цифр. Рассмотрим БД предназначенную для хранения траекторий движения кораблей в океане, параметров кораблей, параметров движения. Траекторию движения можно записать в текстовое поле большого размера, но осуществлять осмысленный поиск по такому текстовому полю будет достаточно трудно. В этом случае для хранения траекторий разрабатываются специальные программные средства, с привлечением знаний по геодезии, картографии.

Объектно-реляционная СУБД позволяет загружать подобный код, предназначенный для обработки «нетипичных» данных. Таким образом, база данных сохраняет свою табличную структуру, но способ обработки некоторых полей таблиц определяется извне, т.е. программистом.


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 2. Основные понятия реляционных баз данных

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**РЕЛЯЦИОННАЯ МОДЕЛЬ**

**Основные понятия реляционных баз данных**

Реляционная модель данных (РМД) некоторой предметной области представляет собой набор отношений, изменяющихся во времени. При создании информационной системы совокупность отношений позволяет хранить данные об объектах предметной области и моделировать связи между ними.



|**Элемент реляционной модели**|**Форма представления**|
| - | - |
|Отношение|Таблица|
|Заголовок (схема) отношения|Заголовок таблицы|
|Кортеж|Строка таблицы|
|Сущность|Описание свойств объекта|
|Атрибут|Заголовок столбца таблицы|
|Домен|Множество допустимых значений атрибута|
|Значение атрибута|Значение поля в записи|
|Первичный ключ|Один или несколько атрибутов|
|Тип данных|Тип значений элементов таблицы|


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**РЕЛЯЦИОННАЯ МОДЕЛЬ**

**Пример: отношение СТУДЕНТ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.014.png)**

**ОСНОВНЫЕ ПОНЯТИЯ**

**Отношение**

**Отношение** представляет собой двумерную таблицу, содержащую некоторые данные.

В шапке таблицы записана **схема отношения**. В строках записаны **кортежи отношения**. Имена столбцов данной таблицы соответствуют именам **атрибутов**. При этом не всякой таблице можно поставить в соответствие отношение. Укажем условия, при выполнении которых таблица будет задавать некоторое отношение:

1. Все строки таблицы должны быть различными, т.е. не может быть двух строк с одинаковыми значениями.
1. Имена столбцов таблицы должны быть различными.
1. В каждой ячейке таблицы должно быть записано только одно значение из домена, соответствующего столбцу.
1. Все строки одной таблицы должны иметь одинаковую структуру, соответствующую шапке таблицы.
1. Порядок размещения строк в таблице может быть произвольным.

**ОСНОВНЫЕ ПОНЯТИЯ**

**Сущность**

**Сущность** есть объект любой природы, данные о котором хранятся в базе данных. Данные о сущности хранятся в отношении.

Сущность – это то, о чем необходимо записывать информацию. Отсюда следует, что сущности (а значит, и связи) имеют некоторые свойства (properties), соответствующие тем данным о них, которые мы желаем записать, и эти свойства должны сохраняться в базе данных. В общем случае свойства могут быть как простыми, так и сложными, причем настолько, насколько это потребуется.

**Домен**

**Домен** представляет собой множество всех возможных значений определенного атрибута отношения.

В процедурных языках программирования каждое переменное должно иметь тип, т. е. принадлежать некоторому типу данных, в реляционных БД каждый элемент данных должен принадлежать некоторому домену. Заметим, данные считаются сравнимыми тогда и только тогда, когда они относятся к одному домену.

**ОСНОВНЫЕ ПОНЯТИЯ**

**Атрибут**

**Атрибуты** представляют собой свойства, характеризующие сущность. В структуре таблицы каждый атрибут именуется и ему соответствует заголовок некоторого столбца таблицы. Формально, если переставить атрибуты в отношении, то получается новое отношение. Однако в реляционных БД перестановка атрибутов не приводит к образованию нового отношения.

**Заголовок отношения (схема отношения)**

**Заголовком** (или схемой) **RelHead** отношения **Rel** называется конечное множество упорядоченных пар вида **<A, T>**, где **A** – имя атрибута, а **T** – имя базового типа или ранее определенного домена. По определению требуется, чтобы все имена атрибутов в заголовке отношения были различны.

**Кортеж**

**Кортежем RelTrip**, соответствующим заголовку **RelHead**, называется последовательность упорядоченных триплетов вида **<A, T, v>**, по одному такому триплету для каждого атрибута в заголовке **RelHead**. Третий элемент – **v** – триплета **<A, T, v>** должен являться допустимым значением типа данных или домена **T**.

**ОСНОВНЫЕ ПОНЯТИЯ**

**Тело**

**Телом** (или содержимым отношения) **RelBody** отношения **Rel** называется произвольное множество кортежей **RelTrip**. Могут существовать такие кортежи **RelTrip**, которые соответствуют заголовку **RelHead**, но не входят в тело **RelBody**.

**Значение отношения**

**Значением RelVal** (Relation value) отношения **Rel** называется пара множеств **RelHead** и **RelBody**.

**Переменная отношения**

Таблицы в БД фактически являются переменными отношений, т.е. их значения – это значения отношений (различные значения отношений в разное время).

**Переменной отношения RelVar** называется именованный контейнер, который может содержать любое допустимое значение **RelVal**. В изменчивой реляционной базе данных хранятся отношения, значения которых изменяются во времени. Естественно, что при определении любой переменной **RelVar** требуется указывать соответствующий заголовок отношения **RelHead**.

**ОСНОВНЫЕ ПОНЯТИЯ**

**Пример**

Старое значение отношения ПРЕДМЕТ заменено новым значением отношения. Старое и новое значения концептуально являются разными. Операция удаления строки – это упрощенный способ записи для определенной операции реляционного присвоения.

- ∖ УД,120![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.015.png)

Языковыми средствами эту операцию можно задать так:

ПРЕДМЕТ : ПРЕДМЕТ  **MINUS** ( ПРЕДМЕТ **WHERE** Название\_предмета =“УД” );



|**Название\_предмета**|**Часы**|
| - | - |
|Матан|100|
|МОПС|80|
|ТОИ|60|
|УД|120|

|**Название\_предмета**|**Часы**|
| - | - |
|Матан|100|
|МОПС|80|
|ТОИ|60|
**ОСНОВНЫЕ ПОНЯТИЯ**

**Степень отношения**

**Степенью** или арностью, заголовка отношения, кортежа, тела отношения, значения отношения и переменной отношения называется мощность заголовка отношения. Степень отношения СТУДЕНТ равна четырем, т. е. оно является 4-арным (кватернарным).

**Кардинальность** – количество кортежей в отношении.

**Первичный ключ**

Первичным ключом (ключом отношения, ключевым атрибутом) называется атрибут (множество атрибутов) отношения, однозначно идентифицирующий каждый из его кортежей. Ключ состоящий из одного атрибута называют **простым**, а состоящий из нескольких атрибутов – **составным** (сложным). Например, в отношении СТУДЕНТ ключевым является атрибут {**Номер\_л\_д**}.

**ПОТЕНЦИАЛЬНЫЙ КЛЮЧ**

Возможны случаи, когда отношение имеет несколько комбинаций атрибутов, каждая из которых однозначно определяет все кортежи отношения. Все эти комбинации атрибутов являются возможными (потенциальными) ключами отношения.

Пусть **K** – множество атрибутов переменной отношения **R**. Множество **K** будет **потенциальным ключом** переменной отношения **R** тогда и только тогда, когда оно обладает следующими свойствами:

1) **Уникальность**. Никакие допустимые значения переменной отношения **R** не содержат двух различных кортежей с одинаковыми значениями атрибутов множества **K**.
1) **Неизбыточность**. Никакое из собственных подмножеств множества **K** не обладает свойством уникальности.

Любой из потенциальных ключей может быть выбран как первичный. Ключи используют для достижения следующих целей:

1) исключения дублирования значений в ключевых атрибутах (остальные атрибуты в расчет не принимаются);
1) упорядочения кортежей;
1) ускорения обращения к кортежам отношения;
1) организации связывания таблиц.

**ПЕРВИЧНЫЙ КЛЮЧ (PRIMARY KEY)**

На практике первичный ключ не всегда выбирают, он может быть задан заказчиком БД.

Понятие первичного ключа является важным в связи с понятием целостности баз данных. На практике первичные (и потенциальные) ключи переменных отношений появляются в результате явных указаний проектировщика отношения. Определяя переменную отношения, проектировщик моделирует часть предметной области, данные из которой будет содержать база данных. Например, известно, что никакие два студента, ни в какой момент времени не могут иметь личное дело с одним и тем же номером. Поэтому можно явно объявить {**Номер\_л\_д**} потенциальным ключом. Можно решить, что у всех студентов разные полные имена, и объявить возможным ключом {**ФИО**}. Затем необходимо оценить, какой из возможных ключей является более надежным (свойство его уникальности никогда не будет отменено) и выбрать наиболее надежный потенциальный ключ в качестве первичного (в нашем случае естественным выбором был бы ключ {**Номер\_л\_д**}, потому что решение об уникальности полных имен студентов выглядит искусственным).

Проектировщик должен явно объявлять первичный и потенциальные ключи переменных отношений. В результате этого объявления СУБД получает информацию, которая в дальнейшем будет использоваться как ограничения целостности. СУБД никогда не допустит появления в переменной отношения значения отношения, содержащего два кортежа с одинаковым значением атрибута {**Номер\_л\_д**} (определение первичного ключа для данной переменной отношения отменить нельзя). Появление двух кортежей с одинаковым значением атрибута {**ФИО**} будет также невозможно до тех пор, пока остается в силе определение {**ФИО**} как потенциального ключа. Тем самым объявления первичного и потенциальных ключей дают СУБД возможность поддерживать целостность базы данных даже в случае попыток занесения в нее некорректных данных.

**ВНЕШНИЙ КЛЮЧ (FOREIGN KEY)**

Пусть в отношении **R2** имеется атрибут **B**, значения которого являются значениями ключевого атрибута **A** другого отношения **R1**. Тогда говорят, что атрибут **B** отношения **R2** есть внешний ключ.

Пусть **R2** – некоторая переменная отношение. Внешний ключ (**FK**) в переменной отношении **R2** представляет собой множество атрибутов этой переменной отношения, такое что:

1) существует переменная отношение **R1** с потенциальным ключом (**PК**) (переменные отношения **R1** и **R2** необязательно различны);
1) каждое значение внешнего ключа **FK** в текущем значении переменной отношения **R2** обязательно совпадает со значением ключа **PК** некоторого кортежа в текущем значении переменной отношения **R1**.

Атрибут называется внешним ключом, потому что его значения однозначно характеризуют сущности, представленные кортежами некоторого другого отношения (т. е. задают значения их первичного ключа).

Внешний ключ может быть составным, т. е. состоять из нескольких атрибутов. Говорят, что отношение, в котором определен внешний ключ, ссылается на соответствующее отношение, в котором такой же атрибут является первичным ключом.

Реляционная модель накладывает на внешние ключи ограничение для обеспечения целостности данных, называемое ссылочной целостностью. Это означает, что каждому значению внешнего ключа должны соответствовать строки в связываемых отношениях.

**ВНЕШНИЙ КЛЮЧ**

**Пример**



|**Название\_предмета**|**Часы**|
| - | - |
|Матан|100|
|МОПС|80|
|ТОИ|60|
|УД|120|

|**Номер\_л\_д**|**ФИО**|**Группа**|**Специальность**|
| - | - | - | - |
|1232|Алексеев А. А.|И-11|Инф. Системы|
|1233|Борисов Б. Б.|И-11|Инф. Системы|
|1234|Васькин В. В.|И-11|Инф. Системы|
|1235|Гришин Г. Г.|М-11|Менеджмент|


|**Номер\_л\_д**|**ФИО**|**Название\_предмета**|**Оценка**|
| - | - | - | - |
|1232|Алексеев А. А.|Матан|Хорошо|
|1233|Борисов Б. Б.|Матан|Отлично|
|1235|Гришин Г. Г.|УД|Удовлетворительно|
|1232|Алексеев А. А.|УД|Хорошо|
**ОСНОВНЫЕ ПОНЯТИЯ**

**Тип данных**

Значения данных, хранимых в реляционной базе данных, являются типизированными, т. е. известен тип каждого хранимого значения.

**Тип данных** задает множество значений данного типа, набор операций, применимых к значениям типа и способ внешнего представления значений типа (литералов). Обычно в современных реляционных базах данных допускается хранение символьных, числовых данных (точных и приблизительных), специализированных числовых данных (например, «деньги»), специальных «темпоральных» данных (дата, время, временной интервал).

**Реляционная база данных**

**Реляционная база данных** – это набор пар <**RelVar, RelHead**> (конечно, каждая переменная отношения в любой момент времени содержит некоторое значение отношение, в частности, пустое).

В классических реляционных базах данных после определения схемы базы данных могли изменяться только значения переменных отношений. Однако теперь в большинстве реализаций допускается и изменение схемы базы данных: определение новых и изменение заголовков существующих переменных отношений. Это принято называть **эволюцией схемы** базы данных.

**ФУНДАМЕНТАЛЬНЫЕ СВОЙСТВА ОТНОШЕНИЙ**

1. **Отсутствие кортежей-дубликатов**

Тело любого отношения никогда не содержит кортежей-дубликатов. Это следует из определения тела отношения как множества кортежей. В теории множеств любое множество состоит из различных элементов. Очевидно, что понятие «кортежей-дубликатов» совершенно бессмысленно. Это свойство служит хорошей иллюстрацией того факта, что отношение и таблица – это не одно и тоже. В общем случае таблица может иметь одинаковые строки, отношение не может содержать одинаковые кортежи в принципе.

2. **Отсутствие упорядоченности кортежей (сверху вниз)**

Отсутствие упорядоченности кортежей в значении отношения также является следствием определения тела отношения как множества кортежей. Тело отношения – это математическое множество, а множества в математике не упорядочены. В отношении СТУДЕНТ кортежи отношения могли бы располагаться в противоположном порядке, но оно при этом осталось бы тем же самым отношением. В отношении нет понятий позиционной адресации и следования.

Это свойство:

1) облегчает построение полного механизма реляционной модели данных, включая базовые средства манипулирования данными – реляционные алгебру и исчисление;
1) позволяет хранить упорядоченные списки кортежей в условиях интенсивно обновляемой базы данных гораздо сложнее технически, а поддержка упорядоченности влечет за собой существенные накладные расходы;
1) придает СУБД дополнительную гибкость при хранении баз данных во внешней памяти и при выполнении запросов к базе данных.

**ФУНДАМЕНТАЛЬНЫЕ СВОЙСТВА ОТНОШЕНИЙ**

3. **Отсутствие упорядоченности атрибутов (слева направо)**

Атрибуты отношений не упорядочены, поскольку по определению заголовок отношения есть множество пар <имя атрибута, имя домена>. В отношении СТУДЕНТ атрибуты могли быть представлены в другом порядке, например {Номер\_л\_д, ФИО, Специальность, Группа}. Это было бы то же самое отношение с точки зрения реляционной модели.

Аналогично правилам обращения к элементам записи или структуры в языках программирования, для ссылки на значение атрибута в кортеже отношения всегда используется имя атрибута.

4. **Атомарность значений атрибутов, первая нормальная форма отношения**

Значения всех атрибутов являются атомарными (вернее, скалярными). Каждый кортеж содержит ровно одно значение для каждого атрибута. Это следует из определения домена как потенциального множества значений скалярного типа данных, т. е. среди значений домена не могут содержаться значения с видимой структурой, в том числе множества значений (отношения).

Принято говорить, что в реляционных базах данных допускаются только нормализованные отношения, или отношения, представленные в первой нормальной форме (**1НФ**). Нормализованные отношения составляют основу классического реляционного подхода к организации баз данных. Они обладают некоторыми ограничениями (не всякую информацию удобно представлять в виде плоских таблиц), но существенно упрощают манипулирование данными.

**АТОМАРНОСТЬ ЗНАЧЕНИЙ АТРИБУТОВ**

**Пример ненормализованного отношения** 



|**Группа**|**Код\_группы**|
| - | - |
|**Номер\_л\_д**|**ФИО**||
|1232|Алексеев А. А.|И-11|
|1233|Борисов Б. Б.||
|1234|Васькин В. В.||
|1235|Гришин Г. Г.|М-11|


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 3. Реляционная модель данных (продолжение)

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ОПЕРАЦИИ РЕЛЯЦИОННОЙ АЛГЕБРЫ**

Три операции реляционной алгебры (объединения, взятия разности и декартова произведения) являются **примитивными** – их нельзя выразить друг через друга. Операцию пересечения можно выразить через операции объединения и взятия разности. Однако эта операция была включена Коддом сигнатуру реляционной алгебры из соображений удобства. Операции объединения, пересечения и декартова произведения ассоциативны. Кроме того, операции объединения и пересечения коммутативны.

Два отношения **совместимы по построению расширенного декартова произведения** в том и только в том случае, если пересечение множеств имен атрибутов, взятых из их схем отношений, пусто. На практике отношения-операнды часто обладают одноименными атрибутами. Однако любые два отношения всегда можно сделать совместимыми по взятию декартова произведения, если применить к одному из них операцию **переименования** атрибутов.

Операцию взятия декартова произведения как отдельную операцию на практике применяют крайне редко. Эта операция включена в сигнатуру реляционной алгебры Кодда, поскольку на ее основе удобно определять операцию соединения. В общем случае операция декартова произведения множеств не коммутативна.

Необходимость удаления дубликатов очень сильно усложняет реализацию операции **проекции**, поскольку в общем случае для удаления дубликатов требуется сортировка промежуточного результата операции. Этот промежуточный результат может быть очень большим, и для сортировки требуется применять алгоритмы внешней сортировки, выполняемые с применением обменов с внешней памятью и требующие значительные временные затраты.


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ОПЕРАЦИИ РЕЛЯЦИОННОЙ АЛГЕБРЫ**

**Отношение эквивалентности**

Введем на множестве реляционных отношений **отношение эквивалентности**. Будем говорить, что реляционные отношения  и  эквивалентны, если

1) Множество атрибутов { , 2,…, } отношения  и множество атрибутов { 1, 2,…, } отношения  равны;
1) Для каждого кортежа ( 1, ,…, ) ∈ найдется равный ему кортеж ( , 2,…, ), полученный из кортежа ( 1, ,…, ) ∈ после 

1 2 1 2

переупорядочивания элементов в соответствии со схемой отношения  , и обратно, для каждого кортежа из  найдется кортеж, полученный после переупорядочивания кортежа из  в соответствии со схемой отношения  .

Например, эквивалентны два отношения, таблицы которых приведены ниже

**Отношение 1 Отношение 2**



|**A**|**B**|**C**|
| - | - | - |
|a1|b1|c1|
|a2|b2|c2|

|**B**|**C**|**A**|
| - | - | - |
|b2|c2|a2|
|b1|c1|a1|
Расширенное декартово произведение, определенное на классах эквивалентности по введенному отношению, будет коммутативно. Действительно, в реляционных отношениях  **TIMES** и  **TIMES** множества атрибутов равны, количество элементов в обоих отношениях совпадают, и п.2 определения эквивалентности также выполняется. Следовательно, эти два отношения эквивалентны, т.е. принадлежат одному классу.

**ОПЕРАЦИИ РЕЛЯЦИОННОЙ АЛГЕБРЫ**

**Деление по модулю**

Мы рассмотрели оригинальную версию операции деления **DIVIDEBY**, предложенную Эдгаром Коддом. Кристофер Дейт предложил свою версию операции деления, «деление  на  по модулю  »  **DIVIDEBY PER** . Иногда эту операцию называют **Small Divide**.

Пусть отношения  и  имеют заголовки { , ,… , } и { , 2,… , } соответственно (заголовки отношений  и  не пересекаются). Заголовок отношения  является объединением заголо1вко2в отношений  1и  и имеет следующий вид: { , 2,… , , 1, ,… , }. Множества { , 2,… , } и 

{ 1, 2,… , } будем рассматривать как составные атрибуты  и  соответственно. Отношение1  – делимое, отн2ошение  – делитель, а о1тношение  – «посредник». Результатом деления отношения  на отношение  по отношению  ( **DIVIDEBY PER** ), называется отношение с заголовком { } и 

телом, содержащим множество всех кортежей вида { : }, таких, что кортеж вида { : , : } принадлежит отношению  для всех кортежей вида { : }, принадлежащих отношению  .

Нестрого это можно сформулировать так: результат содержит такие  -значения из отношения  , для которых соответствующие  -значения из отношения 

включают все  -значения из отношения  .

**ОПЕРАЦИИ РЕЛЯЦИОННОЙ АЛГЕБРЫ**

**Деление по модулю**

**M C D M DIVIDEBY D PER C**



|**S**|
| - |
|S1|
|S2|
|S3|
|S4|
|S5|

|**S**|**P**|
| - | - |
|S1|P1|
|S1|P2|
|S1|P3|
|S1|P4|
|S1|P5|
|S1|P6|
|S2|P1|
|S2|P2|
|S3|P2|
|S4|P2|
|S4|P4|
|S4|P5|

|**P**|
| - |
|P2|
|P4|

|**S**|
| - |
|S1|
|S4|
**ЗАЧЕМ НУЖНА РЕЛЯЦИОННАЯ АЛГЕБРА**

Реляционная алгебра введена для обработки отношений. В множество ее операций входят следующие: выборки, проекции, произведения, объединения, пересечения, вычитания, соединения и деления плюс операция переименования атрибутов **RENAME**. За исключением **RENAME**, эти операции составляют набор, впервые определенный Коддом. Восемь операторов Кодда не представляют минимального набора операторов (они и задумывались не с этой целью), так как не все из них примитивны и часть из них можно определить в терминах других операторов. В действительности три операции из этого набора, а именно — соединение, пересечение и деление, можно определить через остальные пять операций (выборка, проекция, произведение, объединение и вычитание). Эти операции можно рассматривать как **примитивные**, ни одна из них не выражается через другие. Поэтому минимальный набор (необязательно единственно возможный) будет состоять из этих пяти примитивных операций. Однако на практике остальные три операции (в особенности операция соединения) используются настолько часто, что имеет смысл обеспечить их непосредственную поддержку, несмотря на то, что они не являются примитивными.

Основная цель алгебры – **обеспечить запись реляционных выражений**. Возможные применения подобных выражений:

- Определение области выборки, т.е. тех данных, которые должны быть доставлены в результате выполнения операции выборки.
- Определение области обновления, т.е. данных, которые должны быть вставлены, изменены или удалены в результате выполнения операции обновления.
- Определение правил поддержки целостности данных, т.е. некоторых особых требований, которым должна удовлетворять база данных.
- Определение производных переменных-отношений, т.е. тех данных, которые должны быть включены в представления или «моментальные снимки» состояния базы данных.

В целом, выражения реляционной алгебры служат для символического высокоуровневого представления намерений пользователя. И именно потому, что подобные выражения являются символическими и высокоуровневыми, ими можно манипулировать в соответствии с различными символическими высокоуровневыми правилами преобразования.

**ЗАЧЕМ НУЖНА РЕЛЯЦИОННАЯ АЛГЕБРА**

Например, рассмотрим следующее выражение «Получить имена поставщиков детали с номером “Р2”».

Рассмотрим отношения  (соответствие поставщиков и деталей) и  (описание поставщиков). Соединим отношения  и  по общему атрибуту S# и затем выберем те строки, где атрибут P# принимает значение “P2”. Запишем это выражением реляционной алгебры: PROJECT ((SP NATURAL JOIN S) WHERE P#P2) [SNAME] . Его можно преобразовать в логически эквивалентное выражение следующего вида: PROJECT((SP WHERE P#P2) NATURAL JOIN S) [SNAME].

Таким образом, реляционная алгебра может служить хорошим основанием для выполнения **оптимизации**. Следовательно, если пользователь выразил свой запрос с помощью первого из двух приведенных выше выражений, то перед выполнением оптимизатор должен преобразовать его во второе выражение (в идеальном случае производительность не должна зависеть от формы, в которой пользователь выражает свой запрос).

Благодаря своей фундаментальной природе реляционная алгебра часто используется в качестве критерия возможностей выражения пользовательских намерений для некоторого определенного реляционного языка (например, такого, как язык SQL).

Язык называют **реляционно полным**, если его возможности, соответствуют возможностям, обеспечиваемым алгебраическими операциями. Иначе говоря, если выражения этого языка позволяют определить каждое отношение, которое может быть определено с помощью алгебраических выражений (первоначальной алгебры).

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция расширения EXTEND**

В алгебре Кодда нет средств для скалярных вычислений. На практике такие возможности просто необходимы. Например, может понадобиться запросить из базы данных результат вычисления некоторого арифметического выражения или сослаться на результат вычисления в выражении **WHERE** при выборке. Для обеспечения таких возможностей предназначена операция расширения **EXTEND**.

Результатом операции расширения отношения  c заголовком ( 1, 2,…, ) является отношение, заголовок которого ( 1, 2,…, , ), получается ( 1, 2,…, , ), где ( 1, 12,…2 , ) ∈) о,танозшнаечнеиняия и аетсртиьбзунтаачен,иуек аззааднаннонгоог ов  сокпаелряарцниоиг ор авсышриаржеенниияя, а тел. о состоит из кортежей вида 

объединением заголовка ( , ,…,

**EXTEND ADD** ( ) AS 

При этом отношение  не должно иметь атрибута  и выражение не должно ссылаться на атрибут  . Типом переменной  будет тип выражения 

.

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция расширения EXTEND**

**P EXTEND P ADD ( WEIGHT \* 454 ) AS GMWT**



|**P#**|**PName**|**Color**|**Weight**|**City**|
| - | - | - | - | - |
|P1|Nut|Red|12,0|London|
|P2|Bolt|Green|17,0|Paris|
|P3|Screw|Blue|17,0|Rome|
|P4|Screw|Red|14,0|London|
|P5|Cam|Blue|12,0|Paris|
|P6|Cog|Red|19,0|London|

|**P#**|**PName**|**Color**|**Weight**|**City**|**GMWT**|
| - | - | - | - | - | - |
|P1|Nut|Red|12,0|London|5448,0|
|P2|Bolt|Green|17,0|Paris|7718,0|
|P3|Screw|Blue|17,0|Rome|7718,0|
|P4|Screw|Red|14,0|London|6356,0|
|P5|Cam|Blue|12,0|Paris|5448,0|
|P6|Cog|Red|19,0|London|8626,0|
**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Обобщающие функции**

Общее назначение этих функций состоит в том, чтобы на основе значений некоторого атрибута определенного отношения получить скалярное значение.

Примерами являются функции **COUNT**, **SUM**, **MAX**, **MIN**, **ALL** И **ANY**. Параметр <вызов обобщающей функции> является особым случаем параметра <exp>(<скалярное выражение>) в выражении **EXTEND ADD** ( ) **AS** . В общем случае имеет следующий вид:<имя функции> (<реляционное выражение>[, <имя атрибута>]). Если параметр <имя функции> имеет значение COUNT, то параметр <имя атрибута> недопустим и должен быть опущен.

В остальных случаях параметр <имя атрибута> может быть опущен тогда и только тогда, когда параметр <реляционное выражение> задает отношение со степенью, равной единице. Тогда единственный атрибут результирующего отношения, получаемого после вычисления выражения <реляционное выражение>, будет использоваться по умолчанию. Пример:

**SUM** (SP **WHERE** S#  'S1', QTY)

Это выражение позволяет подсчитать суммарный объем всех поставок для поставщика с номером “S1”. Если аргумент обобщающей функции оказывается пустым множеством, то функции **COUNT** и **SUM** возвращают значение “нуль”, а функции **MIN** и **МАХ** – наименьшее и наибольшее значения соответствующего домена. Функции **АLL** и **ANY** в этом случае возвращают соответственно значения истина и ложь, а функция **AVG** генерирует исключительную ситуацию.

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция обобщения SUMMARIZE**

Пусть  – исходное отношение c заголовком ( , ,…, ), а отношение  – проекция отношения  на атрибуты , ,…, . Результатом операции обобщения **SUMMARIZE** отношения  является1отношение  , заголовок которого ( 1, ,…, , ), получается объе1дин2ением заголовка 

2

( 1, 2,…, ) отношения  и добавляемого атрибута  . Тело отношения  состоит из 2кортежей  вида ( 1, 2,…, , ), где ( 1, 2,…, ) ∈ . Значение  нового атрибута  , есть результат вычисления значения выражения < > по всем кортежам отношения  , которые имеют те же значения 

для атрибутов , ,…, , что и кортеж .

1 2

Синтаксис

**SUMMARIZE PER ADD** < exp > **AS**

Здесь  – исходное отношение,  – проекция отношения А, < > – допустимое скалярное выражение,  – имя добавляемого атрибута.

Атрибута  не должно быть в списке атрибутов отношения  и в выражении < >. Поскольку проецирование, как правило, приводит к сокращению количества кортежей по отношению к исходному отношению (удаляются кортежи c одинаковыми значениями атрибутов ( 1, 2,…, )), то можно считать, что происходит группирование кортежей исходного отношения: одному кортежу отношения  соответствует один или более (если было дублирование при проецировании) кортежей исходного отношения  .

Выражение < > часто называют обобщающим выражением. Кардинальность результата равна кардинальности отношения  , а степень результата равна степени отношения  плюс единица. Типом переменной  в этом случае будет тип выражения  .

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция обобщения SUMMARIZE**

**SP SUMMARIZE SP PER SP [P#] ADD SUM (QTY) AS TOTQTY**



|**S#**|**P#**|**QTY**|
| - | - | - |
|S1|P1|300|
|S1|P2|200|
|S1|P3|400|
|S1|P4|200|
|S1|P5|100|
|S1|P6|100|
|S2|P1|300|
|S2|P2|400|
|S3|P2|200|
|S4|P2|200|
|S4|P4|300|
|S4|P5|400|

|**P#**|**TOTQTY**|
| - | - |
|P1|600|
|P2|1000|
|P3|400|
|P4|500|
|P5|500|
|P6|100|
**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Транзитивное замыкание**

Пусть  – произвольное бинарное отношение с атрибутами **X** и **Y**, принадлежащими одному типу  . Тогда транзитивным замыканием отношения  (что записывается как **TCLOSE** ) называется отношение  +, заголовок которого такой же, как заголовок отношения  , а тело является супермножеством отношения  .

Супермножество отношения  определяется следующим образом. Кортеж {**Х:х**, **Y:y**} принадлежит отношению  + тогда и только тогда, когда он принадлежит отношению  или когда существует последовательность значений 1, 2,…, (принадлежащих типу  ), такая, что все кортежи {**Х:х**, **Y:** }, {**Х:** , **Y:** }, ... , {**Х:** , **Y:y**} принадлежат отношению  . Иначе говоря, кортеж (**х**,**у**) принадлежит отношению  + только тогда, когда (нестрого говоря) в представляющем отношение  графе есть линия, соединяющая точку **х** с точкой **у**. Тело отношения  всегда содержится в теле отношения  + как подмножество.

Рассмотрим отношение  , содержащее информацию о людях, родившихся в некоторой местности. Эта отношение, как правило, содержит о персоне и сведения о его родителях. Общие сведения о персоне содержат номер записи в отношении  , ФИО и др. сведения. Номер записи служит первичным ключом. В отношение могут иметься записи о персонах, для родителей которых сведения о номере записи в отношении  отсутствуют.

Построим новое отношение  , как проекцию отношения  номер записи персоны, номер записи родителя. Транзитивное замыкание отношение позволит определить всех родственников и построить генеалогическое дерево для выбранной персоны.

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Транзитивное замыкание**

**A TCLOSE A**



|**Конструкция**|**Где используется**|
| - | - |
|Болт|Двигатель|
|Болт|Колесо|
|Гайка|Двигатель|
|Гайка|Колесо|
|Двигатель|Автомобиль|
|Колесо|Автомобиль|
|Ось|Колесо|

|**Конструкция**|**Где используется**|
| - | - |
|Болт|Двигатель|
|Болт|Колесо|
|Гайка|Двигатель|
|Гайка|Колесо|
|Двигатель|Автомобиль|
|Колесо|Автомобиль|
|Ось|Колесо|
|Болт|Автомобиль|
|Гайка|Автомобиль|
|Ось|Автомобиль|
**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ SPQ**

|**S#**|**PQ**|
| - | - |
|S1|P#|QTY|
||P1|300|
||P2|200|
||P3|400|
||P4|200|
||P5|100|
||P6|100|
|S2|P#|QTY|
||P1|300|
||P2|400|
|S3|P#|QTY|
||P2|200|
|S4|P#|QTY|
||P2|200|
||P4|300|
||P5|400|
**Операция группирования**

**SP**



|**S#**|**P#**|**QTY**|
| - | - | - |
|S1|P1|300|
|S1|P2|200|
|S1|P3|400|
|S1|P4|200|
|S1|P5|100|
|S1|P6|100|
|S2|P1|300|
|S2|P2|400|
|S3|P2|200|
|S4|P2|200|
|S4|P4|300|
|S4|P5|400|
**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция группирования**

Рассмотрим выражение  **GROUP** (P#, QTY) **AS** .

Выражение  **GROUP** (P#, QTY) **AS** можно прочесть как “сгруппировать отношение  по атрибуту  #”, поскольку атрибут  # является единственным атрибутом отношения  , не упомянутым в предложении GROUP. В результате получится таблица с заголовком {S# , PQ}, где атрибут S# совпадает со одноименным атрибутом отношения  . Атрибут имеет тип отношение, его значениями являются отношения, с атрибутами Р# и QTY,(PQ:RELATION {P#, QTY}).

Таблица содержит ровно по одному кортежу  для всех различных значений атрибута S# исходного отношения  (и никаких других кортежей). Каждый кортеж  = ( , ) содержит соответствующее значение  атрибута  #( ), а также значение атрибута  ( ), полученное следующим образом:

- Каждый кортеж отношения  заменяется кортежем  , в котором компоненты Р# и QTY “упакованы” в один компонент  : = ( , ); = ( , );
- Компоненты  всех кортежей  , значение S# которых равно  , “группируются” в отношение  , и таким образом получается результирующий кортеж, в котором значение # равно  , а значение  равно  .

**ДОПОЛНИТЕЛЬНЫЕ ОПЕРАТОРЫ**

**Операция разгруппирования**

Пусть  – это таблица из предыдущего примера. Тогда выражение **UNGROUP** возвращает нас к отношению  .

Если определенным образом сгруппировать некоторое отношение  , то всегда будет существовать обратная операция разгруппирования, позволяющая вернуться к отношению  . Но, если сначала разгруппировать некоторое отношение  , то обратная операция группирования, возвращающая нас к отношению  , будет существовать не всегда.


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 3. Реляционная модель данных

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**РЕЛЯЦИОННАЯ МОДЕЛЬ ДАННЫХ**

Модель данных описывает некий набор родовых понятий и признаков, которыми должны обладать все конкретные СУБД и управляемые ими базы данных, если они основываются на этой модели. Наличие модели данных позволяет сравнивать конкретные реализации, используя один общий язык.

Понятие модели данных в области баз данных было введено английским математиком Эдгаром Коддом применительно к реляционным системам и наиболее эффективно используется именно в данном контексте.

Им были предложены «12 правил Кодда» (Codd's 12 rules) – 12 правил, которым должна удовлетворять каждая система управления реляционными базами данных.


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**12 ПРАВИЛ КОДДА**

1. **Явное представление данных (The Information Rule)**

Информация должна быть представлена в виде данных, хранящихся в ячейках. Данные, хранящиеся в ячейках, должны быть атомарны. Порядок строк в реляционной таблице не должен влиять на смысл данных.

2. **Гарантированный доступ к данным (Guaranteed Access Rule)**

Доступ к данным должен быть свободен от двусмысленности. К каждому элементу данных должен быть гарантирован доступ с помощью комбинации имени таблицы, первичного ключа строки и имени столбца.

3. **Полная обработка неизвестных значений (Systematic Treatment of Null Values)**

Неизвестные значения NULL, отличные от любого известного значения, должны поддерживаться для всех типов данных при выполнении любых операций. Например, для числовых данных неизвестные значения не должны рассматриваться как нули, а для символьных данных – как пустые строки.

**12 ПРАВИЛ КОДДА**

4. **Доступ к словарю данных в терминах реляционной модели (Dynamic On-Line Catalog Based on the Relational Model)**

Словарь данных должен сохраняться в форме реляционных таблиц, и система управления реляционными базами данных должна поддерживать доступ к нему при помощи стандартных языковых средств, тех же самых, которые используются для работы с реляционными таблицами, содержащими пользовательские данные.

5. **Полнота подмножества языка (Comprehensive Data Sublanguage Rule)**

Система управления реляционными базами данных должна поддерживать единственный язык, который позволяет выполнять все операции доступа к данным: операции определения данных, манипулирования данными, управления доступом к данным, управления транзакциями.

6. **Возможность модификации представлений (View Updating Rule)**

Каждое представление должно поддерживать все операции манипулирования данными, которые поддерживают реляционные таблицы: операции выборки, вставки, модификации и удаления данных.

**12 ПРАВИЛ КОДДА**

7. **Наличие высокоуровневых операций управления данными (High-Level Insert, Update, and Delete)**

Операции вставки, модификации и удаления данных должны поддерживаться не только по отношению к одной строке реляционной таблицы, но по отношению к любому множеству строк.

8. **Физическая независимость данных (Physical Data Independence)**

Приложения не должны зависеть от используемых способов хранения данных на носителях, от аппаратного обеспечения компьютеров, на которых находится реляционная база данных.

9. **Логическая независимость данных (Logical Data Independence)**

Представление данных в приложении не должно зависеть от структуры реляционных таблиц. Если в процессе нормализации одна реляционная таблица разделяется на две, представление должно обеспечить объединение этих данных, чтобы изменение структуры реляционных таблиц не сказывалось на работе приложений.

**12 ПРАВИЛ КОДДА**

10. **Независимость контроля целостности (Integrity Independence)**

Вся информация, необходимая для поддержания целостности, должна находиться в словаре данных. Язык для работы с данными должен выполнять проверку входных данных и автоматически поддерживать целостность данных.

11. **Дистрибутивная независимость (Distribution Independence)**

База данных может быть распределенной, может находиться на нескольких компьютерах, и это не должно оказывать влияние на приложения. Перенос базы данных на другой компьютер не должен оказывать влияния на приложения.

12. **Согласование языковых уровней (Non-Subversion Rule)**

Не должно быть иного средства доступа к данным, отличного от стандартного языка для работы с данными. Если используется низкоуровневый язык доступа к данным, он не должен игнорировать правила безопасности и правила целостности, которые поддерживаются языком более высокого уровня.

**ОБЩАЯ ХАРАКТЕРИСТИКА**

Одним из первых осознал важность работ Кодда по реляционной модели Кристофер Дейт. В своих работах Дейт развил теорию Кодда применительно к прикладным задачам проектирования реляционных баз данных. Согласно трактовке Дейта, реляционная модель состоит из трех частей, описывающих разные аспекты реляционного подхода:

1) структурная часть;
1) манипуляционная часть;
1) целостная часть.

В **структурной части** модели фиксируется, что единственной родовой структурой данных, используемой в реляционных БД, является нормализованное *n*- арное отношение. Определяются понятия доменов, атрибутов, кортежей, заголовка, тела и переменной отношения. Все эти понятия мы уже рассматривали.

В **манипуляционной части** модели определяются две группы языков, имеющие в качестве своей математической основы теоретические языки запросов, предложенные Коддом и основанные на:

- реляционной алгебре;
- реляционном исчисление.

Эти языки эквивалентны друг другу по своим возможностям. Существуют правила преобразования запросов между ними.

В **целостной части** реляционной модели данных (РМД) фиксируются два базовых требования целостности, которые должны поддерживаться в любой реляционной СУБД. Это целостность сущности и ссылок.

**ЦЕЛОСТНОСТЬ СУЩНОСТИ (ENTITY INTEGRITY)**

**Требование целостности сущности**: у любой переменной отношения должен существовать первичный ключ, и никакое значение первичного ключа в кортежах не должно содержать неопределенных значений.

Теоретически любой кортеж, добавляемый в отношение, должен содержать все характеристики моделируемой им сущности. Однако в момент добавления записи значения некоторых атрибутов могут быть неизвестны. Например, в отношении СТУДЕНТ до проведения первой сессии у студента нет экзаменационных оценок. В этом случае сотрудник отдела кадров, который заносит в отношение СТУДЕНТ кортеж, описывающий нового студента, просто не может обеспечить значение атрибута {**Оценка**} в отношение СТУДЕНТ\_ПРЕДМЕТ (Номер\_л\_д, ФИО, Название\_предмета, Оценка). Здесь мы предполагаем, что атрибут {**Название\_предмета**} внесен в таблицу на основании учебного плана.

Кодд предложил использовать в таких случаях неопределенные значения NULL. Неопределенное значение не принадлежит никакому типу данных. В БД, поддерживающих понятие NULL, при описании поля таблицы определяется, может ли оно быть пустым. Если да, то в это поле можно не записывать никакого значения, и это поле будет иметь значение NULL. Значение NULL можно явно записать в такое поле.

Большинство СУБД не разрешает значение NULL для полей, являющихся частью первичного ключа таблицы. В полях внешних ключей NULL допускается. Наличие NULL в поле внешнего ключа может трактоваться как признак отсутствия связанной записи, и для такого внешнего ключа не требуется исполнение правил ссылочной целостности, обязательных для любого другого значения внешнего ключа.

**ОПЕРАЦИИ С NULL**

NULL не является значением в строгом смысле этого слова, т.к. у него нет типа. Поэтому его использование в арифметических, логических и других операциях некорректно, поскольку все операции определены для работы с конкретными типами данных. Для корректного использования значения NULL вводят специальные правила:

1. NULL может присваиваться переменным и записываться в поля, независимо от объявленного типа данных этих переменных (полей);
1. NULL может передаваться в процедуры и функции как допустимое значение параметра. Результаты выполнения такой процедуры или функции определяются операциями, выполняемыми с параметрами внутри неё;
1. любая операция с NULL, кроме операции сравнения, в результате даёт NULL, независимо от значения прочих операндов;
1. любая операция сравнения с NULL (даже операция «NULL  NULL»), даёт в результате значение «неизвестность» (UNKNOWN);
1. существует специальная системная функция, которая возвращает логическое значение «истина» (TRUE), если аргумент функции является NULL и «ложь» (FALSE) в противном случае.

**ОПЕРАЦИИ С NULL**

Рассмотрим подробнее пункты 3 и 4. Пусть **a** – это значение некоторого типа данных или NULL, **op** – любая бинарная «арифметическая» операция для данных этого типа (например, +), а **comp\_op** – операция сравнения значений этого типа (например, ). Тогда по определению:

*a op NULL = NULL*

*NULL op a = NULL*

*a comp\_op NULL = unknown*

*NULL comp\_op a = unknown*

**unknown** обладает следующими свойствами: *NOT unknown = unknown*

*true AND unknown = unknown*

*true OR unknown = true*

*false AND unknown = false*

*false OR unknown = unknown*

Значения любого атрибута, входящего в первичный ключ, не может быть неопределенным (NULL). В классической реляционной модели это требование распространяется и на потенциальные ключи. В SQL-ориентированных СУБД такое требование к потенциальным ключам не выдвигается.

Таким образом, для соблюдения целостности сущности достаточно обеспечить отсутствие в любом отношении различных кортежей с одним и тем же значением первичного ключа и запретить присвоение неопределенных значений атрибутам, входящим в первичный ключ.

**ЦЕЛОСТНОСТЬ ПО ССЫЛКАМ (REFERENTIAL INTEGRITY)**

Сущности реального мира представить в БД в виде одного отношения достаточно сложно. Поэтому любая база данных содержит несколько отношений. Между отношениями должны быть установлены связи. Наличие связей между отношениями является основным свойством любой реляционной базы данных. Поскольку отношения в БД хранятся в виде таблиц, часто говорят об установлении связей между таблицами.

Связи в реляционной БД устанавливаются с помощью использования внешних ключей. Для установления связи между отношениями **A** и **B** одно или несколько полей (атрибутов) отношения **B** объявляются **внешним ключом** (foreign key). Во внешний ключ записывается значение первичного ключа отношения, связанного с данным. Конкретнее, когда мы говорим о том, что между отношениями установлены связи, мы имеем в виду связи между каждым кортежем в отношении **B** с определёнными кортежами в отношении **A**. Для этого в поле внешнего ключа кортежа отношения **B** записывается первичный ключ связанного с ним кортежа отношения **A**. После установления связей мы всегда можем определить, с каким кортежем в отношении **A** связан определённый кортеж отношения **B**, и найти все кортежи отношения **B**, имеющие связи с определённым кортежем отношения **A**.

Переменная отношение, которая содержит внешний ключ, называется **ссылающейся переменной отношения**, а переменная отношение, которая содержит соответствующий первичный ключ, – **ссылочной переменной отношением**.

**ЦЕЛОСТНОСТЬ ПО ССЫЛКАМ**

Пусть отношение **A** содержит поля **a**, **b**, **c**, **d**, из которых поле **a** – первичный ключ. Отношение **B** содержит поля **e**, **f**, **g**, **h**. В поле **g** содержится значение поля **a** одной из записей отношения **A**. В таком случае поле **g** и называется внешним ключом. Это поле организует связь между двумя отношениями.

**Отношение A Отношение B**



|**e**|**f**|**g**|**h**|
| - | - | - | - |
|e1|f1|a1|h1|
|e2|f2|a2|h2|
|e3|f3|a1|h3|

|**a**|**b**|**c**|**d**|
| - | - | - | - |
|a1|b1|c1|d1|
|a2|b2|c2|d2|
Например, SQL-запрос: 

**select \* from A, B where A.a =B.g** вернёт все связанные пары записей из отношений A и B.

Внешний ключ (как и первичный) задается при описании отношения и представляет собой ограничение на допустимые значения. Определение внешнего ключа представляет собой определение ограничения целостности базы данных.

**ЦЕЛОСТНОСТЬ ПО ССЫЛКАМ**

Проблему контроля того, чтобы база данных не включала никаких неверных значений внешних ключей, называют проблемой поддержания **ссылочной целостности**. Ограничение, в соответствии с которым значения данного внешнего ключа должны отвечать значениям соответствующих первичных ключей, называют ссылочным ограничением.

**Ссылочная целостность** (referential integrity) – необходимое качество реляционной базы данных, заключающееся в отсутствии в любом её отношении внешних ключей, ссылающихся на несуществующие кортежи в этом или других отношениях. Пусть даны два отношения **A** и **B**, связанных внешним ключом. Первичный ключ отношения **A** – поле **A.key**. Внешний ключ отношения **B**, ссылающийся на **A** – поле **B.a**. Ссылочная целостность для двух отношений **A** и **B** имеет место тогда, когда выполняется условие: для каждого кортежа отношения **B** существует соответствующий кортеж в отношении **A**, то есть кортеж, у которого **A.key** =**B.a**.

Требование целостности по ссылкам (целостности внешнего ключа) состоит в том, что для каждого значения внешнего ключа должен найтись кортеж с таким же значением первичного ключа, либо значение внешнего ключа должно быть полностью неопределенным (т. е. ни на что не указывать). База данных обладает свойством ссылочной целостности только тогда, когда для любой пары входящих в нее отношений, связанных внешним ключом отношений выполняется условие ссылочной целостности.

Ограничения целостности сущности и целостности по ссылкам должны поддерживаться СУБД.

**ЦЕЛОСТНОСТЬ ПО ССЫЛКАМ**

Соблюдение целостности по ссылкам значительно сложнее, чем соблюдение целостности сущности. При обновлении ссылающегося отношения (вставке новых кортежей или модификации значения внешнего ключа в существующих кортежах) достаточно следить за тем, чтобы не появлялись некорректные значения внешнего ключа. Гораздо хуже дело обстоит при удалении кортежа из отношения, на которое ведет ссылка.

Существуют три подхода, поддерживающих целостность по ссылкам при удалении данных.

1. **Запрет**. Удаление кортежа, на который имеются ссылки, производить запрещается (т. е. сначала нужно либо удалить ссылающиеся кортежи, либо соответствующим образом изменить значения их внешнего ключа). При попытке удаления кортежа операция блокируется и возвращается ошибка.
1. **Обнуление внешних ключей**. При удалении кортежа, на который имеются ссылки, во всех ссылающихся кортежах значение внешнего ключа автоматически становится полностью неопределенным (NULL).
1. **Каскадное удаление**. При удалении кортежа из отношения, на которое ведет ссылка, из ссылающегося отношения автоматически удаляются все ссылающиеся кортежи. Если хотя бы для одной из ссылающихся записей это невозможно (например, если поле внешнего ключа описано так, что его нельзя обнулять), то удаление запрещается.

В развитых реляционных СУБД обычно можно выбрать способ поддержания целостности по ссылкам для каждого случая определения внешнего ключа. Конечно, для приняия такого решения необходимо анализировать требования конкретной прикладной области.

**ЦЕЛОСТНОСТЬ ПО ССЫЛКАМ**

**Пример нарушения ссылочной целостности**



|**Key**|**Name**|**Street**|**House**|**Apartment**|
| - | - | - | - | - |
|1|Жилин|11|22|12|
|2|Зотов|23|11|27|
|3|Иванов|39|34|563|
|4|Бекларян|NULL|54|89|
|5|Маркес|5|65|43|
|6|Кокорин|19|98|67|
|7|Фортнайтов|43|26|34|
|8|Пабгов|16|5|5|
|9|Петров|51|6|4|

|**Key**|**Prefix**|**Name**|
| - | - | - |
|5|улица|Тимирязевкая|
|11|переулок|Кочновский|
|16|проспект|Кутузовский|
|19|улица|Бутырская|
|23|улица|Маршала Жукова|
|39|проспект|Ленинградский|
|49|переулок|Плотников|
|51|проспект|Мира|
|68|улица|Чуйская|
**select** \* **from** Address, Street **where** Address.Street  Street. Key

В данном примере ссылочная целостность нарушена. Одна запись в отношении АДРЕС (Key 7) имеет в поле  **Street** так называемую «**висящую**» ссылку – значения, которому не соответствуют записи в отношении УЛИЦА. Из-за этого результат приведённого запроса не будет содержать этой записи – для нее условие запроса не выполнится. И ещё одна запись не будет выбрана этим запросом – запись таблицы АДРЕС (Key 4). Это вариант намеренного нарушения ссылочной целостности – в поле внешнего ключа записан NULL.

**ПОДДЕРЖАНИЕ ССЫЛОЧНОЙ ЦЕЛОСТНОСТИ В БД**

**Причины нарушений**

Правильно спроектированная и поддерживаемая БД не допускает возможности нарушения ссылочной целостности. Тем не менее, такие нарушения могут появиться в ходе эксплуатации базы по целому ряду причин. Некоторые из них:

1. **Некорректная работа прикладного программного обеспечения**. Понятно, что при ошибке в программе, выполняющей модификацию БД, база может быть модифицирована недопустимым образом, в результате чего образуются висящие ссылки. Программа может совершать ошибки следующих видов:
- **Неполная запись объектов**. Данные объекта размещаются в записях нескольких таблиц, а программа не записывает какую-то из них.
- **Некорректная правка ссылки**. Значение внешнего ключа изменяется на такое, которому не соответствует ни одна запись в связанной таблице.
- **Правка первичного ключа без каскадного обновления**. В таблице, на которую есть ссылки, правится первичный ключ, но при этом внешние ключи в связанных с ней таблицах остаются без изменения.
- **Удаление записи без каскадного обновления**. Из таблицы удаляется запись, на которую имеются ссылки по внешним ключам других таблиц, при этом в связанных записях внешние ключи не меняются. В результате все ссылающиеся на неё записи других таблиц становятся некорректными.
2. **Сбои в работе системного программного обеспечения и оборудования**. Такие сбои могут привести к нарушению ссылочной целостности, даже если прикладное программное обеспечение работает совершенно правильно. Например, если при добавлении объекта в БД нужно добавить несколько связанных записей в несколько таблиц, то в процессе добавления данных ссылочная целостность всегда нарушается, когда часть связанных записей уже добавлена, а часть – ещё нет, и восстанавливается только после завершения операции. Если во время выполнения операции произойдет сбой (из-за переполнения диска, сбоя питания, или по каким-то другим причинам), и операция будет прервана, то часть записей будет добавлена в БД, часть – нет. В результате часть добавленных записей будет иметь некорректные ссылки.

**МАНИПУЛЯЦИОННАЯ ЧАСТЬ РМД**

Манипуляционная часть реляционной модели данных состоит из реляционной алгебры, основанной на теории множеств и теории отношений, и реляционного исчисления, опирающегося на теорию исчисления предикатов. Выделяются два вида реляционного исчисления – исчисление кортежей и исчисление доменов.

Использование алгебраических методов и методов теории предикатов позволяет сложные запросы к базе данных выражать одной формулой достаточно простого вида. В реляционной алгебре операнды и результаты всех действий являются отношениями. Языки реляционной алгебры являются процедурными, так как отношение, являющееся результатом запроса к реляционной БД, вычисляется при выполнении последовательности реляционных операторов, применяемым к отношениям. Операторы состоят из операндов, в роли которых выступают отношения, и реляционных операций. Результатом реляционной операции является отношение.

Языки исчислений, в отличие от реляционной алгебры, являются непроцедурными (описательными, или декларативными) и позволяют выражать запросы с помощью предиката первого порядка (высказывания в виде функции), которому должны удовлетворять кортежи или домены отношений. Запрос к БД, выполненный с использованием подобного языка, содержит лишь информацию о желаемом результате. Для этих языков характерно наличие наборов правил для записи запросов. В частности, к языкам этой группы относится SQL.

Любой запрос может быть выражен как с помощью некоторой формулы реляционной алгебры, так и с помощью предикатной формулы. С этой точки зрения алгебраический и предикатный подходы эквивалентны. Язык манипулирования реляционными БД называется **реляционно-полным**, если любой корректный запрос, формулируемый с помощью одного выражения реляционной алгебры или одной формулы реляционного исчисления, может быть сформулирован с помощью одного оператора этого языка.

**РЕЛЯЦИОННАЯ АЛГЕБРА КОДДА**

Данный вариант реляционной алгебры предложен Дейтом. Отношения являются множествами и к ним можно применить традиционные теоретико- множественные операции. Кроме того на отношениях можно задать некоторые специальные операции, необходимые для работы с реляционными базами данных. Известно несколько подходов к определению реляционной алгебры, которые различаются наборами операций и способами их задания. Мы будем изучать вариант алгебры, предложенный Коддом, в который добавлены некоторые операции («алгебра Кодда»). Реляционная алгебра в том виде, в котором она была определена Коддом, состоит из восьми операций, составляющих две группы по четыре операции.

1. Теоретико-множественные операции:
- объединение отношений;
- пересечение отношений;
- разность отношений;
- декартово произведение отношений.

Указанные операции выполняются с учетом того, что их операндами являются отношения (состоящие из тела и заголовка), а не некоторые множества.

2. Специальные реляционные операции:
- ограничение отношения;
- проекция отношения;
- соединение отношений;
- деление отношений.

**КРАТКИЙ ОБЗОР ОПЕРАЦИЙ**

Для справки, в теории множеств имеют место следующие определения:

- объединение множеств  и  есть множество всех таких  , что  является элементом хотя бы одного множества  или  :

∪ = { : ∈ ∨ ∈ }

- пересечение множеств  и  есть множество всех таких  , что  является одновременно элементом множества  и элементом множества  :

∩ = { : ∈ ∧ ∈ }

- разность множеств и  есть множество всех таких  , что элемент  принадлежит множеству  , но не принадлежит множеству  :

∖ = { : ∈ ∧ ∉ }

- множество всех кортежей длины  на множествах  ,..., называют прямым произведением множеств  ,..., и обозначают  ×...× 1 ×...× = { 1,…, : 1 ∈ 1,…, ∈ }![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.016.png)

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.017.png)

**СОВМЕСТИМОСТЬ ПО ТИПУ**

В реляционной алгебре мы имеем дело с отношениями, которые состоят из тела отношения и заголовка отношения. Наличие заголовка является существенной особенностью операндов реляционной алгебры. Отношения, имеющие одинаковые заголовки называют **совместимыми по типу**. К таким отношениям можно применять операции объединения отношений, пересечения отношений и разность отношений.

**Студенты, изучающие дополнительно английский язык Студенты, изучающие дополнительно немецкий язык**



|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
|1235|Гришин Г. Г.|М-11|

|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1235|Гришин Г. Г.|М-11|
|1237|Иванов И. В.|Л-11|
|1240|Степанов А. С.|К-11|
**ОБЪЕДИНЕНИЕ**

Операцию объединения можно применять только к отношениям совместимым по типу (имеющим одинаковые заголовки). Результатом объединения двух совместимых по типу отношений **A** и **B** является отношение с тем же заголовком, что и у отношений **A** и **B**, и телом, состоящим из кортежей, принадлежащих или **A**, или **B**, или обоим отношениям одновременно.

Синтакcис: *A* **UNION** *B* Альтернатива:  ∪

**Студенты\_английский UNION Студенты\_немецкий**



|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
|1235|Гришин Г. Г.|М-11|
|1237|Иванов И. В.|Л-11|
|1240|Степанов А. С.|К-11|
**ПЕРЕСЕЧЕНИЕ**

Операцию объединения можно применять только к совместимым по типу отношениям. Результатом пересечения двух совместимых по типу отношений **A** и **B** является отношение с тем же заголовком, что и у отношений **A** и **B**, и телом, состоящим из кортежей, принадлежащих отношениям **A** и **B** одновременно.

Синтакcис: *A* **INTERSECT** *B* Альтернатива:  ∩

**Студенты\_английский INTERSECT Студенты\_немецкий**



|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1235|Гришин Г. Г.|М-11|
**РАЗНОСТЬ**

Операцию разности можно применять только к совместимым по типу отношениям. Результатом разности двух совместимых по типу отношений **A** и **B** является отношение с тем же заголовком, что и у отношений **A** и **B**, и телом, состоящим из кортежей, принадлежащих отношению **A** и не принадлежащих отношению **B**.

Синтакcис: *A* **MINUS** *B* Альтернатива:  ∖

**Студенты\_английский MINUS Студенты\_немецкий**



|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
**ПРЯМОЕ ПРОИЗВЕДЕНИЕ (ДЕКАРТОВО ПРОИЗВЕДЕНИЕ)**

Декартово произведение отношений можно применять к отношениям заголовки которых не содержат одноименных атрибутов, принадлежащих одному домену. Результатом декартова произведение отношения **A** c заголовком ( 1, 2,…, ) и отношения **B** c заголовком ( 1, 2,…, ) является отношение, заголовок которого ( 1, 2,…, , , 2,…, ), является соединением (конкатенацией) заголовка ( , 2,…, ) отношения **A** и 

заголовка ( 1, ,…, ) отношения **B**, а тело со1стоит из кортежей ( , 2,…, , , ,…, ), где ( 1, 2,…, 1) ∈ , ( 1, ,…, ) ∈ . 

2 1 1 2 2

Синтакcис: *A* **TIMES** *B* Альтернатива:  ×

При необходимости найти декартово произведение отношений, заголовки которых содержат одноименные атрибуты, принадлежащие одному домену, используют операцию переименования атрибутов, которая будет описана ниже.

**ПРЯМОЕ ПРОИЗВЕДЕНИЕ (ДЕКАРТОВО ПРОИЗВЕДЕНИЕ)**

**Студенты Преподаватели**



|**Номер\_пропуска**|**ФИО\_преподавателя**|
| - | - |
|2323|Болтенко Б. Б.|
|2339|Петрушин П. П.|

|**Номер\_л\_д**|**ФИО\_студента**|**Группа**|
| - | - | - |
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
**Студенты TIMES Преподаватели**



|**Номер\_л\_д**|**ФИО\_студента**|**Группа**|**Номер\_пропуска**|**ФИО\_преподавателя**|
| - | - | - | - | - |
|1233|Борисов Б. Б.|И-11|2323|Болтенко Б. Б.|
|1233|Борисов Б. Б.|И-11|2339|Петрушин П. П.|
|1234|Васькин В. В.|И-11|2323|Болтенко Б. Б.|
|1234|Васькин В. В.|И-11|2339|Петрушин П. П.|
**ОГРАНИЧЕНИЕ ОТНОШЕНИЯ (RESTRICT)**

Эта операция является унарной. Результатом применения операции ограничения, заданного условием **p**, к отношению **A** является отношение с тем же заголовком, что и у отношения **A**, тело которого состоит из таких кортежей, для которых условие **p** выполняется при подстановке в него значения атрибутов этого кортежа. Условие **p** представляет собой логическое выражение, в которое входят атрибуты отношения **A** и может иметь значение ЛОЖЬ или ИСТИНА. Операцию ограничения также иногда называют операцией **выборки**.

Синтакcис: *A **WHERE** p* Альтернатива:  ( )

**Студенты\_английский WHERE Группа “И-11”**



|**Номер\_л\_д**|**ФИО**|**Группа**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
**ПРОЕКЦИЯ**

Результатом применения операции проекции, заданной заголовком ( 1, 2,…, ), к отношению **A** с заголовком ( , ,…, ), где  ∈![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.018.png)

1, 2,…, , = 1… , ≠ , ≠ ,  является отношение с заголовком ( 1, 2,…, ) и телом, содержащим1мно2жество кортежей вида 

( 1, 2,…, ), таких, для которых в отношении **A** найдутся кортежи со значением атрибута 1 равным  1, значением атрибута  2 равным  2, …, значением атрибута  равным  .

Синтакcис: **PROJECT** *A[* 1, 2,…, *]* Альтернатива: 

1, 2,…, ( )

**PROJECT Студенты\_английский[ФИО, Группа]**



|**ФИО**|**Группа**|
| - | - |
|Алексеев А. А.|И-11|
|Борисов Б. Б.|И-11|
|Васькин В. В.|И-11|
|Гришин Г. Г.|М-11|
**ПЕРЕИМЕНОВАНИЕ**

Операция переименования (**RENAME**) – девятая операция реляционной алгебры, дополняющая «начальную» алгебру Кодда.

При выполнении некоторых операций могут возникнуть сложности с корректным формированием заголовка отношения. Например, рассмотрим построение декартова произведения отношения **A** и отношения **B** (*A* **TIMES** *B*). Пусть у отношений **A** и **B** имеются одноименные атрибуты из одинаковых доменов. Согласно определению декартова произведения, заголовок отношения-результата является соединением заголовка первого отношения **A** и заголовка второго отношения **B**. При формировании заголовка результирующего отношения сначала будут записаны атрибуты первого отношения, затем второго. Однако с формальной точки зрения получается не кортеж атрибутов, а множество. Это множество не может содержать одинаковые элементы. Следовательно, один из пары одноименных атрибутов исчезнет из результата, что недопустимо. В этом случае корректное выполнение операции декартова произведения невозможно. Аналогичные проблемы могут возникнуть и в других случаях.

Для разрешения проблемы формирования заголовка отношения, являющегося результатом некоторой реляционной операции, в число операций реляционной алгебры введена унарная операция переименования атрибутов заголовка отношения. Для заданного отношения операция RЕNАМЕ возвращает другое отношение, тело которого совпадает с телом исходного отношения, а заголовок получается из заголовка исходного отношения путем переименования одного или нескольких атрибутов.

Синтакcис: *A* **RENAME** 1, 2,…, **AS**  1, 2,…, Альтернатива:  ( )

1/ 1, 2/ 2,…, /

**ПЕРЕИМЕНОВАНИЕ**

**Студенты\_английский RENAME Группа AS Group**



|**Номер\_л\_д**|**ФИО**|**Group**|
| - | - | - |
|1232|Алексеев А. А.|И-11|
|1233|Борисов Б. Б.|И-11|
|1234|Васькин В. В.|И-11|
|1235|Гришин Г. Г.|М-11|
**СОЕДИНЕНИЕ**

Операция соединения имеет несколько разновидностей:

- общая операция соединения;
- эквисоединение;
- естественное соединение;
- левое (правое) полусоединение;
- левое (правое) антисоединение;
- левое (правое) внешнее соединение;
- полное внешнее соединение.

**ОБЩАЯ ОПЕРАЦИЯ СОЕДИНЕНИЯ (**Θ**-СОЕДИНЕНИЕ)**



|<p>Операнды операции соединения (**JOIN**) отношения **A** и **B** должны быть совместимы по построению расширенного декартова произведения. Результатом применения операции соединения отношений **A** и **B** по условию, заданному логическим выражением **p**, является отношение **R**, заголовок которого совпадает с заголовком декартова произведения отношений **А** и **В**, а тело содержит множество кортежей **t**, таких, что кортеж **t** принадлежит декартову произведению отношений **А** и **В**, и условие **p** для кортежа **t** истинно.</p><p>Операция соединения есть результат последовательного применения операций декартового произведения и выборки. Если в отношениях и имеются атрибуты с одинаковыми наименованиями, то перед выполнением соединения такие атрибуты необходимо переименовать.</p><p>Синтаксис: (*A* **TIMES** *B*) **WHERE** Θ , где вместо Θ может быть указан один из операторов сравнения  >,>=,<,<=,=,<> Альтернатива: A ⋈ Θ</p><p>Операция эквисоединения (**EQUIJOIN**) характеризуется тем, что логическое выражение **p** задает равенство операндов  = .</p>|
| :- |
**ОБЩАЯ ОПЕРАЦИЯ СОЕДИНЕНИЯ (**Θ**-СОЕДИНЕНИЕ)**

**Машины Мотоциклы**



|**Название\_машины**|**Цена\_машины**|
| - | - |
|Машина\_A|20000|
|Машина\_B|30000|
|Машина\_C|50000|

|**Название\_мотоцикла**|**Цена\_мотоцикла**|
| - | - |
|Мотоцикл\_A|10000|
|Мотоцикл\_B|40000|
|Мотоцикл\_C|60000|
**(Машины TIMES Мотоциклы) WHERE Цена\_машины >= Цена\_мотоцикла**



|**Название\_машины**|**Цена\_машины**|**Название\_мотоцикла**|**Цена\_мотоцикла**|
| - | - | - | - |
|Машина\_A|20000|Мотоцикл\_A|10000|
|Машина\_B|30000|Мотоцикл\_A|10000|
|Машина\_C|50000|Мотоцикл\_A|10000|
|Машина\_C|50000|Мотоцикл\_B|40000|
**ЕСТЕСТВЕННОЕ СОЕДИНЕНИЕ**

Операция естественного соединения (**NATURAL JOIN**) применяется к двум отношениям, имеющим общий атрибут (простой или составной). Этот атрибут в отношениях имеет одно и то же имя (совокупность имен) и определен на одном и том же домене (доменах).

Естественным соединением называется соединение по эквивалентности двух отношений **A** и **B**, выполненное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута.

Синтаксис: *A* **NATURAL JOIN** *B* Альтернатива: A ⋈

**ЕСТЕСТВЕННОЕ СОЕДИНЕНИЕ**

**Сотрудники Отделы**



|**Название\_отдела**|**Телефон**|
| - | - |
|Бухгалтерия|33333|
|Стратегия|44444|
|Планирование|55555|

|**Номер**|**ФИО**|**Название\_отдела**|
| - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|
|1236|Болтенко Б. Б.|Кадры|
**Сотрудники NATURAL JOIN Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|**Телефон**|
| - | - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|33333|
|1234|Васькин В. В.|Стратегия|44444|
|1235|Алексеев А. А.|Бухгалтерия|33333|
**ЛЕВОЕ (ПРАВОЕ) ПОЛУСОЕДИНЕНИЕ**

Операция левого (правого) полусоединения (**SEMIJOIN**) определяет отношение, содержащее те кортежи отношения **A** (**B**), которые входят в естественное соединение отношений **A** и **B**.

Синтаксис: *A* **LEFT SEMIJOIN** *B* или *A* **RIGHT SEMIJOIN** *B* Альтернатива: A ⋉ или A ⋊

**Сотрудники Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|
| - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|
|1236|Болтенко Б. Б.|Кадры|

|**Название\_отдела**|**Телефон**|
| - | - |
|Бухгалтерия|33333|
|Стратегия|44444|
|Планирование|55555|
**Сотрудники LEFT SEMIJOIN Отделы Сотрудники RIGHT SEMIJOIN Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|
| - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|

|**Название\_отдела**|**Телефон**|
| - | - |
|Бухгалтерия|33333|
|Стратегия|44444|
**ЛЕВОЕ (ПРАВОЕ) АНТИСОЕДИНЕНИЕ**

Операция левого (правого) антисоединения (**ANTIJOIN**) является дополнением к операции левого (правого) полусоединения.

Синтаксис: *A* **LEFT ANTIJOIN** *B* или *A* **RIGHT ANTIJOIN** *B* Альтернатива: A ⊳ или A ⊲

**Сотрудники Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|
| - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|
|1236|Болтенко Б. Б.|Кадры|

|**Название\_отдела**|**Телефон**|
| - | - |
|Бухгалтерия|33333|
|Стратегия|44444|
|Планирование|55555|
**Сотрудники LEFT ANTIJOIN Отделы Сотрудники RIGHT ANTIJOIN Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|
| - | - | - |
|1236|Болтенко Б. Б.|Кадры|

|**Название\_отдела**|**Телефон**|
| - | - |
|Планирование|55555|
**ЛЕВОЕ (ПРАВОЕ) ВНЕШНЕЕ СОЕДИНЕНИЕ**

Левым (правым) внешним соединением (**OUTER JOIN**) называется естественное соединение, при котором кортежи отношения **A**, не имеющие совпадающих значений в общих столбцах c отношением **B**, также включаются в результирующее отношение.

Синтаксис: *A* **LEFT OUTER JOIN** *B* или *A* **RIGHT OUTER JOIN** *B*

Альтернатива: A⟕ или A⟖

**Сотрудники Отделы**



||||
| :- | :- | :- |
|**Номер**|**ФИО**|**Название\_отдела**|
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|
|1236|Болтенко Б. Б.|Кадры|

|||
| :- | :- |
|**Название\_отдела**|**Телефон**|
|Бухгалтерия|33333|
|Стратегия|44444|
|Планирование|55555|
**Сотрудники LEFT OUTER JOIN Отделы Сотрудники RIGHT OUTER JOIN Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|**Телефон**|
| - | - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|33333|
|1234|Васькин В. В.|Стратегия|44444|
|1235|Алексеев А. А.|Бухгалтерия|33333|
|1236|Болтенко Б. Б.|Кадры|NULL|

|**Номер**|**ФИО**|**Название\_отдела**|**Телефон**|
| - | - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|33333|
|1234|Васькин В. В.|Стратегия|44444|
|1235|Алексеев А. А.|Бухгалтерия|33333|
|NULL|NULL|Планирование|55555|
**ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ**

Полным внешним соединением (**FULL OUTER JOIN**) называется результат объединения левого и правого внешнего соединения.

Синтаксис: *A* **FULL OUTER JOIN** *B*

Альтернатива: ⟗ **Сотрудники Отделы**



||||
| :- | :- | :- |
|**Номер**|**ФИО**|**Название\_отдела**|
|1233|Борисов Б. Б.|Бухгалтерия|
|1234|Васькин В. В.|Стратегия|
|1235|Алексеев А. А.|Бухгалтерия|
|1236|Болтенко Б. Б.|Кадры|

|||
| :- | :- |
|**Название\_отдела**|**Телефон**|
|Бухгалтерия|33333|
|Стратегия|44444|
|Планирование|55555|
**Сотрудники FULL OUTER JOIN Отделы**



|**Номер**|**ФИО**|**Название\_отдела**|**Телефон**|
| - | - | - | - |
|1233|Борисов Б. Б.|Бухгалтерия|33333|
|1234|Васькин В. В.|Стратегия|44444|
|1235|Алексеев А. А.|Бухгалтерия|33333|
|NULL|NULL|Планирование|55555|
|1236|Болтенко Б. Б.|Кадры|NULL|
**ДЕЛЕНИЕ**

, 2,…, ) на отношение **B** с заголовком ( 1 ) есть отношение с заголовком кор1теж ( , 2,…, , , 2,…, ). 1, ,…, 1, 2,…,

Результат делен, итяе лоот нкооштоерноигяо  **A**сосс тзоаигот лиозвмконмож(ес1т,ва2к,о…рт,еже,й 1 2 ), таких, что для всех кортежей (, 2,…, ) из **B** в отношении **A** найдется 

( , 2,…, ) (

1 1

Деление отношений является бинарной операцией. При этом заголовки делимого и делителя должны быть согласованы в указанном выше смысле.

Синтаксис: *A* **DIVIDE BY** *B* **Студенты\_проекты Проекты Студенты\_проекты DIVIDE BY Проекты** Альтернатива: A ÷

|**ФИО**|**Название\_проекта**|
| - | - |
|Борисов Б. Б.|Проект\_A|
|Борисов Б. Б.|Проект\_B|
|Борисов Б. Б.|Проект\_C|
|||
|Васькин В. В.|Проект\_A|
|Васькин В. В.|Проект\_C|
|Васькин В. В.|Проект\_D|
|Алексеев А. А.|Проект\_A|
|Алексеев А. А.|Проект\_B|
|Алексеев А. А.|Проект\_E|

|**Название\_проекта**|
| - |
|Проект\_A|
|Проект\_B|

|**ФИО**|
| - |
|Борисов Б. Б.|
|Алексеев А. А.|
**ЗАМКНУТОСТЬ РЕЛЯЦИОННОЙ АЛГЕБРЫ**

Пусть на множестве  задана  -местная операция  , которая набору элементов  1, 2,…, множества  ставит в соответствие элемент  – результат операции. Замкнутость по отношению к операции означает, что для любых наборов значений  , ,…, из  результат выполнения операции является 

1 2

элементом множества  .

Напомним, что  -местную операцию  можно рассматривать как отображение ∶ → . С этой точки зрения реляционная алгебра представляет собой набор отображений, использующих отношения  , ,…, в качестве аргументов и возвращающих отношение в качестве результата:  =

( 1, 2,…, ). Часто такая форма записи является1бол2ее удобной для записи выражений, составленных из отношений.

Любое корректное выражение, составленное из отношений и операций реляционной алгебры, может интерпретироваться как отношение, и использоваться в других выражениях. Единственное ограничение заключается в том, что необходимо выдерживать ограничения на заголовки операндов, накладываемые применяемыми операциями. Таким образом, в качестве аргументов в реляционные выражения можно подставлять другие реляционные выражения, подходящие по заголовкам, и формировать сложные выражения вида = , ,… , , ,… ,… .![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.019.png)

1 11 12 2 21 22

С формальной точки зрения в реляционное выражение могут входить в качестве составных частей выражения сколь угодно сложной структуры. Однако для контроля согласованности заголовков необходим встроенный в реляционную алгебру набор правил вывода заголовков отношений, который позволял бы определить заголовок результата произвольной реляционной операции по заголовкам операндов. Такие правила для всех операций были указаны при их описании, что гарантирует формирование корректного заголовка отношения, являющегося значением реляционного выражения любой сложности.

**ПРИОРИТЕТЫ ОПЕРАЦИЙ**

Поскольку результатом любой реляционной операции (кроме операции присваивания, которая не вырабатывает значения) является некое отношение, можно образовывать реляционные выражения, в которых вместо отношения-операнда некоторой реляционной операции находится вложенное реляционное выражение. В построении реляционного выражения могут участвовать все реляционные операции, кроме операции присваивания. Вычислительная интерпретация реляционного выражения диктуется установленными приоритетами операций и вычисление выражения производится слева направо с учетом приоритетов операций и скобок.



|**Операция**|**Приоритет**|
| - | - |
|RENAME|4|
|RESTRICT|3|
|PROJECT|3|
|TIMES|2|
|JOIN|2|
|INTERSECT|2|
|DIVIDE BY|2|
|UNION|1|
|MINUS|1|


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 4. Язык SQL – DDL. Язык SQL – DML. Процедурный SQL

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**STRUCTURED QUERY LANGUAGE (SQL)**

В SQL определены два подмножества языка:

- SQL-DDL (Data Definition Language) – язык определения структур и ограничений целостности баз данных. Сюда относятся команды создания и удаления баз данных; создания, изменения и удаления таблиц; управления пользователями и т.д.
- SQL-DML (Data Manipulation Language) – язык манипулирования данными: добавление, изменение, удаление и извлечение данных, управления транзакциями.

Стандарты (далее в лекции будут перечислены функции и операторы из стандарта SQL, их реализации в различных БД могут иметь отличный синтаксис):



|System R IBM язык SEQUEL 1970|Первая реализация Structured Query Language (SQL)|
| - | - |
|SQL/DS IBM 1981|Расширение функционала|
|Первый стандарт SQL – ANSI и ISO 1986|Первый вариант стандарта, принятый институтом ANSI и ISO|
|SQL dialect 1 – ANSI 1987|Окончательная версия первого стандарта|
|SQL-92 – ANSI 1992|Значительное расширение предыдущего стандарта|
|SQL dialect 3 – ANSI 1999|<p>Добавлена поддержка регулярных выражений, рекурсивных запросов, поддержка триггеров, базовые процедурные расширения, </p><p>нескалярные типы данных и некоторые объектно-ориентированные возможности</p>|
|SQL-2003|Расширения для работы с XML-данными, оконные функции, генераторы последовательностей и их типы данных|
|SQL-2006|Расширена функциональность работы с XML-данными. Совместное использование в запросах SQL и XQuery|
|SQL-2008|Улучшены возможности оконных функций, устранены некоторые неоднозначности стандарта SQL-2003|
|SQL-2011|Реализована поддержка хронологических баз данных (PERIOD FOR), поддержка конструкции FETCH|
|SQL-2016|Защита на уровне строк, полиморфные табличные функции, JSON|


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ТИПЫ ДАННЫХ**

Целые числа:

- INTEGER – обычное целое 4 байта;
- SMALLINT – короткое целое 2 байта.

Строки:

- CHAR(n) – символьная строка фиксированной длины n;
- VARCHAR(n) – символьная строка переменной длины, но не более n.

Вещественные типы данных:

- FLOAT – число с плавающей точкой 4 байта;
- DECIMAL(p,n) – p – число знаков до запятой, n – после запятой;
- DOUBLE PRESISION – число с плавающей точкой 8 байт.

Другие типы данных:

- BLOB – двоичные типы данных большого размера;
- DATE – дата с точностью до дня, единица измерения день;
- TIME – время с точностью до мс, единица измерения секунда;
- TIMESTAMP – дата и время вместе.

**СХЕМА БД**

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.020.png)

**SQL-DDL**

Основные операторы управления метаданными:

- CREATE – создать;
- ALTER – изменить;
- DROP – удалить.

Выполняются над сущностями:

- DOMAIN
- TABLE
- VIEW
- PROCEDURE
- TRIGGER
- GENERATOR
- INDEX
- …

**SQL-DDL**

**Управление БД**

**CREATE DATABASE** <путь к БД> **USER** <логин> **PASSWORD** <пароль> […];

CREATE DATABASE ‘10.1.12.4:/var/db/stud.fdb’ USER ‘SYSDBA’ PASSWORD ‘masterkey’ PAGE\_SIZE 16384 DEFAULT CHARACTER SET CYRL; **CONNECT DATABASE** <путь к БД> **USER** <логин > **PASSWORD** <пароль> […];

**DROP DATABASE**;

**Управление таблицами**

**CREATE TABLE** <имя\_таблицы> (< опр\_поля >, …)

<опр\_поля>  < имя\_поля> 

{<тип\_поля> | **COMPUTED BY** (<выражение>) | <домен>} [**DEFAULT** {<литерал> | **NULL** | **USER** | …}]

[**NULL** | **NOT NULL**]

[<огр\_поля>]

CREATE TABLE students (id integer NOT NULL, fname varchar(30), lname varchar(30), yob integer DEFAULT 1985, age COMPUTED BY (2008-yob));

**SQL-DDL**

**Управление таблицами**

**ALTER TABLE** <имя\_таблицы> {**ADD** <опр\_поля>| **DROP** <имя\_поля>},… ALTER TABLE students ADD hobby varchar(20) NOT NULL, DROP group\_id;

**DROP TABLE** <имя\_таблицы>; DROP TABLE students;

**Ограничения**

Ограничения на значения полей таблицы, бывают 4 типа ограничений:

<огр\_поля>  [ **CONSTRAINT** <имя\_огр>] {**PRIMARY KEY** |

**UNIQUE** |

**FOREIGN KEY** (<имя\_поля>) **REFERENCES** <имя\_глав\_таблицы>(<имя\_поля>) | **CHECK** <condition>}

**SQL-DDL**

**Ограничения**

Ограничения первичного ключа – **PRIMARY KEY**

CREATE TABLE students(id integer NOT NULL **PRIMARY KEY**, group\_id integer NOT NULL,

fname varchar(30) NOT NULL,

lname varchar(30),

age integer);

ALTER TABLE students ADD CONSTRAINT pk1 **PRIMARY KEY** (id);

**SQL-DDL**

**Ограничения**

Ограничения уникальности – **UNIQUE**

CREATE TABLE students(id integer NOT NULL **UNIQUE**, group\_id integer NOT NULL,

fname varchar(30) NOT NULL,

lname varchar(30),

age integer);

ALTER TABLE students ADD CONSTRAINT unique1 **UNIQUE** (id);

**SQL-DDL**

**Ограничения**

Ограничения на диапазон значений поля – **CHECK**

CREATE TABLE students(id integer NOT NULL, group\_id integer NOT NULL,

fname varchar(30) NOT NULL,

lname varchar(30),

age integer **CHECK** (age > 18));

ALTER TABLE students ADD CONSTRAINT check1 **CHECK** (age > 18);

**SQL-DDL**

**Ограничения**

Ограничения на диапазон значений поля – **FOREIGN KEY**

CREATE TABLE students(id integer NOT NULL,

group\_id integer NOT NULL,

fname varchar(30) NOT NULL,

lname varchar(30),

age integer,

**CONSTRAINT** fk\_group **FOREIGN KEY**(group\_id) **REFERENCES** groups (id));

ALTER TABLE students ADD CONSTRAINT fk\_group **FOREIGN KEY**(group\_id) **REFERENCES** groups (id);

**SQL-DML**

**Оператор SELECT**

**SELECT** – оператор извлечения записей из таблиц в SQL. Операции реляционной алгебры: ПРОЕКЦИЯ, ВЫБОРКА, СОЕДИНЕНИЕ.

**SELECT** [**ALL** | **DISTINCT**] <список\_выбора> **FROM** <имя\_таблицы>,...

[ **WHERE** <условие> ]

[ **GROUP BY** <имя\_столбца>,... ]

[ **HAVING** <условие> ]

[**ORDER BY** <имя\_столбца> [**ASC** | **DESC**],... ]

Порядок предложений должен строго соблюдаться.

**SQL-DML**

**Оператор SELECT**

- SELECT \* FROM students;
- SELECT id, fname, lname as ‘Фамилия’, age FROM students;
- SELECT fname, lname FROM students WHERE (fname like ‘%A’) and (age > 20);
- SELECT fname, lname FROM students WHERE not (id between 100 and 200);
- SELECT fname, lname FROM students WHERE lname in (‘Ivanov’, ‘Petrov’, ‘Sidorov’);

Операторы:

, <>, >, <,  AND, OR, NOT, LIKE, BETWEEN… AND …, IN (…)

**SQL-DML**

**Оператор SELECT**

Соединение нескольких таблиц:

- SELECT fname, lname, number FROM students, groups;
- SELECT fname, lname, number FROM students, groups WHERE students.group\_id groups.id;
- SELECT fname, lname FROM students, groups WHERE (students.group\_id groups.id) and ( groups.number ‘4081/2’);
- SELECT fname, lname, specs.name FROM students, groups, specs WHERE (students.group\_id groups.id) and ( groups.spec\_id specs.id);

Вычисляемые поля:

- SELECT fname, lname, (2008 - age) AS YoB FROM students;

**SQL-DML**

**Оператор SELECT**

Вычисление совокупных характеристик:

- SELECT MAX(age) FROM students;
- SELECT AVG(mark) FROM students, stud\_results WHERE (students.id  stud\_results.student\_id) and ( lname ‘Ivanov’);

Агрегатные функции: MAX(<поле>), MIN (<поле>), COUNT (<поле>), AVG (<поле>), SUM (<поле>).

Группировка данных:

- SELECT groups.id from students, groups WHERE students.group\_id groups.id;
- SELECT groups.id, COUNT(students.id) from students, groups WHERE students.group\_id groups.id GROUP BY groups.id;
- SELECT fname, lname, AVG(mark) from students, stud\_results WHERE students.id   stud\_results.student\_id GROUP BY lname, fname;

При группировке в выбираемом списке могут быть только поля, к которым применяется группировка и агрегатные функции.

**SQL-DML**

**Оператор SELECT**

Ограничения на результаты группировки:

- SELECT groups.id, COUNT(students.id) as s\_count from students, groups WHERE (students.group\_id groups.id) GROUP BY groups.id HAVING COUNT(students.id) > 10;

Условия могут содержать только выбираемые поля.

Сортировка выбранных записей:

- SELECT fname, lname, age FROM students ORDER BY age;
- SELECT fname, lname, age FROM students ORDER BY fname DESC, lname;

Выбор записей с исключением повторений:

- SELECT DISTINCT fname, lname FROM students;

**SQL-DML**

**Оператор SELECT**

Вложенные запросы в конструкции WHERE:

- SELECT fname, lname FROM students WHERE age  (SELECT MAX(age) FROM students);
- SELECT fname, lname FROM students WHERE (SELECT AVG(mark) FROM stud\_results WHERE stud\_results.student\_id students.id ) > 3.5;

Вложенные запросы в конструкции FROM (виртуальные таблицы):

- SELECT fname, lname, s\_mark FROM students, (SELECT students.id as s\_id, AVG(mark) as s\_mark FROM students, stud\_results WHERE stud\_results.student.id  students.id ) as vt\_marks WHERE (students.id  vt\_marks.s\_id) and ( vt\_marks.s\_mark > 3.5);

Выбор заданного числа записей:

- SELECT FIRST 1 fname, lname FROM students WHERE age  21;
- SELECT FIRST 2 SKIP 1 fname, lname FROM students WHERE age  21;
- SELECT fname, lname FROM students WHERE age  21 ROWS 2 TO 3;

Операторы: FIRST <число>, SKIP <число>, ROWS <число> [TO <число>]

**SQL-DML**

**Оператор SELECT**

Преобразование типов:

- SELECT fname, lname, AVG(CAST(mark AS float)) FROM students, stud\_results WHERE students.id  stud\_results.student\_id GROUP BY fname, lname;

Оператор: CAST (<поле> AS <требуемый\_тип>)

Работа с датой и временем:

- SELECT fname, lname, CURRENT\_DATE - CAST(birthdate AS DATE) FROM students WHERE EXTRACT(month FROM birthdate)  3;
- SELECT CAST(’22.03.2010’ AS DATE);

Операторы: CURRENT\_DATE, CURRENT\_TIME, EXTRACT (year | month | day FROM <поле>), CAST (SYSDATETIME AS DATE | TIME | TIMESTAMP)

**SQL-DML**

**Значение NULL**

Трехзначная логика: TRUE, FALSE, NULL.

Значение NULL – существует для переменных любого типа. Значение NULL – недопустимо для PK и допустимо для FK. Любые операции c полем содержащим NULL дает NULL.

Пусть A  1, B  NULL,  тогда:

- (A + B)  NULL;
- (A  B)  NULL;
- (A || B) = NULL;
- (A <> B) = NULL;
- (B  NULL)  NULL;
- not (B)  NULL.

**SQL-DML**

**Значение NULL**

Логические операции AND и OR с NULL:

- NULL or false  NULL;
- NULL or true  true;
- NULL or NULL  NULL;
- NULL and false  false;
- NULL and true  NULL;
- NULL and NULL  NULL.

Запросы должны учитывать возможность появления NULL для полей у которых явно не указано NOT NULL. NULL может появляться при операциях и при вычислении условий в конструкциях WHERE, HAVING, IF, … . В агрегатных функциях NULL игнорируется, за исключением COUNT(\*).

**SQL-DML**

**Значение NULL**

Примеры запросов не учитывающих появление NULL

- SELECT fname || lname FROM students;
- IF (A <> B) THEN result  ‘NOT EQUAL’ ELSE result  ‘EQUAL’ ;

Операторы обрабатывающие NULL – **DISTINCT** (<>), **NOT DISTINCT** (=) – результат только TRUE или FALSE:

- IF (A IS DISTINCT B) THEN result  ‘NOT EQUAL’ ELSE result  ‘EQUAL’ ;

IS NULL, IS NOT NULL – явные проверки на NULL. **NULLIF**(<выражение 1>, <выражение2>) – если <выражение1> равно NULL, то выдаст <выражение2>.

**SQL-DML**

**INSERT**

Добавление одной записи в таблицу БД.

**INSERT INTO** <имя\_таблицы> [ (<имя\_поля>,...) ] **VALUES** (<значение>,...)

- NSERT INTO students VALUES (1, ‘Иван’, ‘Иванов’, 2, 24);
- INSERT INTO students(id, fname, group\_id) VALUES (1, ‘Иван’, 2);
- INSERT INTO students VALUES (1, ‘Иван’, ‘Иванов’, (SELECT groups.id FROM groups WHERE number ‘4081/1’), 24) ;
- INSERT INTO students VALUES (1, ‘Иван’, ‘Иванов’, (SELECT gid FROM (SELECT FIRST 1 groups.id AS gid, COUNT(students.id) AS s\_count FROM groups, students WHERE students.group\_id groups.id GROUP BY groups.id ORDER BY s\_count)), 24);

**SQL-DML**

**DELETE**

Удаление одной или нескольких записей.

**DELETE FROM** <имя\_таблицы> [ **WHERE** <условие> ]

- DELETE FROM students;
- DELETE FROM groups WHERE number  ‘4081/1’;
- DELETE FROM students WHERE age  (SELECT MAX(age) FROM students);
- DELETE FROM students WHERE (SELECT AVG(CAST(mark AS float)) FROM stud\_results WHERE stud\_results.student\_id students.id ) < 3.5;

**SQL-DML**

**DELETE vs TRUNCATE**

Команда **DELETE** удаляет записи из таблицы, которые удовлетворяют критерию WHERE. **TRUNCATE** удаляет все данные из таблицы.



||**TRUNCATE**||**DELETE**|
| :- | - | :- | - |
|•|TRUNCATE быстрее и использует меньше системных ресурсов, чем DELETE и |•|DELETE удаляет строки в таблицы и для каждой оставляет запись в логе |
||практически не пишет лог транзакции;||транзакции;|
|•|TRUNCATE удаляет данные путем деаллокации тех страниц, которые хранят |•|DELETE не обнуляет счетчик уникальности;|
||табличные данные и только эти операции деаллокации записываются в лог |•|DELETE может использоваться с выражением WHERE или без него;|
||транзакции;|•|DELETE активирует триггеры;|
|•|TRUNCATE удаляет все строки таблицы, но структура таблицы (столбцы, |•|После DELETE возможен откат;|
||ограничения, индексы и т.д.) остается. Счетчик, который используется для |•|DELETE – команда DML.|
||уникальности новых записей обнуляется;|||
|•|Нельзя использовать TRUNCATE TABLE для таблиц, связанных ограничением |||
||FOREIGN KEY;|||
|•|Поскольку TRUNCATE TABLE не логируется, то и не может активировать |||
||триггер;|||
|•|Откат (rollback) после TRUNCATE невозможен;|||
|•|TRUNCATE – команда DDL.|||
**SQL-DML**

**UPDATE**

Изменение атрибутов одной или нескольких записей.

**UPDATE** <имя\_таблицы> **SET** <имя\_столбца><значение>,... [**WHERE** <условие>]

- UPDATE students SET group\_id 1;
- UPDATE students SET group\_id 1 WHERE age > 20;
- UPDATE stud\_results SET mark  4 WHERE id IN (SELECT stud\_results.id FROM  stud\_results, groups WHERE stud\_results.student\_id =groups.main\_student\_id AND stud\_results.semestr 7);
- UPDATE stud\_results SET mark (SELECT max(mark) FROM  stud\_results) WHERE student\_id 1;

**SQL-DML**

**UNION, EXCEPT, INTERSECT**

Объединение результатов из двух выборок.

<выборка1> **UNION** <выборка2>

- SELECT fname, lname FROM Students UNION SELECT fname, lname FROM Teachers;

Вычитание результатов правой выборки из левой выборки. <выборка1> **EXCEPT** <выборка2>

Пересечение результатов двух выборок (включая NULL значение). <выборка1> **INTERSECT** <выборка2>

**SQL-DML**

**OUTER JOIN**

Внешнее соединение таблиц по заданному условию.

<таблица1> [**FULL** | **LEFT** | **RIGHT**] **OUTER JOIN** <таблица2> **ON** <условие>

- SELECT distinct students.fname, students.lname, teachers.fname, teachers.lname FROM students FULL OUTER JOIN teachers

ON students.fname =teachers.fname AND students.lname =teachers.lname;

- SELECT ness\_subject\_id FROM subjects RIGHT OUTER JOIN subject\_rel ON subjects.id  subject\_rel.subject\_id WHERE subjects.name  ‘ Математика‘;

Может заменить соединение таблиц в конструкции WHERE:

- SELECT fname, lname, number FROM students, groups WHERE students.group\_id groups.id;
- SELECT number, fname, lname FROM students LEFT OUTER JOIN groups ON students.group\_id groups.id;
- SELECT fname, lname, specs.info FROM students, groups, specs WHERE (students.group\_id groups.id) and ( groups.spec\_id specs.id);
- SELECT fname, lname, specs.info FROM groups LEFT OUTER JOIN specs ON groups.spec\_id specs.id

LEFT OUTER JOIN students ON students.group\_id groups.id;

**SQL-DML**

**INNER JOIN**

Внутреннее соединение таблиц по заданному условию

- SELECT number, fname, lname FROM students FULL OUTER JOIN groups ON students.group\_id groups.id;
- SELECT number, fname, lname FROM students LEFT OUTER JOIN groups ON students.group\_id groups.id;
- SELECT number, fname, lname FROM students RIGHT OUTER JOIN groups ON students.group\_id groups.id;
- SELECT number, fname, lname FROM students INNER JOIN groups ON students.group\_id groups.id;

**PROCEDURAL SQL**

**VIEW (Представления)**

Представление – именованный SELECT – запрос, хранимый в БД.

**CREATE VIEW** <имя\_представления> [(<имя\_столбца>,...)] **AS** <запрос>

CREATE VIEW studs (fname, lname, number) AS SELECT fname, lname, number from students, groups WHERE students.group\_id groups.id;

Особенности представлений

- Доступно только для чтения.
- Автоматическое обновление данных.
- Может использоваться как обычная таблица.
- Виртуальная таблица, копии данных не создается.
- Поддерживаются вложенные представления.

**PROCEDURAL SQL**

**VIEW (Представления)**

CREATE VIEW gsize(gid, scount) AS SELECT groups.id AS gid, COUNT(students.id) AS s\_count FROM groups, students 

WHERE students.group\_id groups.id GROUP BY groups.id ORDER BY  s\_count desc;

CREATE VIEW bgroup(number) AS SELECT groups.number AS number FROM gsize, groups WHERE groups.id   gsize.gid ROWS 1;

Использование представлений:

- Подготовка данных для клиентского приложения.
- Выполнение часто используемых запросов.
- Декомпозиция сложных запросов.

**PROCEDURAL SQL**

**SQL-программирование**

Поддерживаются следующие возможности:

- Процедуры, триггеры, генераторы, …
- Входные, выходные и внутренние переменные.
- Несколько операторов SQL.
- Операторы ветвления и перехода.
- Операторы цикла.
- Операторы прекращения цикла и выхода из процедуры.
- Оператор возвращающий результат выполнения.
- Исключения.

**PROCEDURAL SQL**

**Оператор SUSPEND**

Возврат результатов выполнения процедуры **SUSPEND**

Особенности выполнения:

- В процедуре может быть несколько SUSPEND.
- В процедуре может не быть SUSPEND.
- Не прерывает процедуру.
- Один SUSPEND может срабатывать несколько раз.

Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Оператор ветвления**

**IF** (<условие>) **THEN** BEGIN

…

END

**ELSE**

BEGIN

…

END

IF (A > 10) THEN BEGIN

A  0;

END
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Оператор FOR**

**FOR** <выборка> **INTO** <:переменная1, …> **DO** BEGIN

…

END

Выбираемые переменные помещаются в список после INTO

FOR SELECT fname FROM students WHERE group\_id IS NOT NULL ORDER BY fname INTO :out\_fname DO BEGIN

IF (CHAR\_LENGTH(out\_fname) > 5) THEN SUSPEND;

END


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Оператор WHILE**

**WHILE** (<условие>) **DO** BEGIN

…

END

WHILE (A < 100) DO

BEGIN

INSERT INTO students(fname, lname) VALUES (‘Иван’, ‘Иванов’); A  A + 1;

END

**PROCEDURAL SQL**

**Операторы BREAK и EXIT**

**BREAK** – выход из цикла

FOR SELECT age, fname from students INTO :var, :name DO BEGIN

IF (var > 20) THEN

BEGIN

SUSPEND;

BREAK;

END

END

**EXIT** – выход из процедуры IF (var > 10) THEN EXIT;

**PROCEDURAL SQL**

**Генераторы**

Генератор – именованный счетчик. **GENERATOR** <gen\_name>

**GEN\_ID** (<gen\_name>, <increment\_value>) **SET GENERATOR** <gen\_name> **TO** <value>

CREATE GENERATOR gen\_stud\_id; SET GENERATOR gen\_stud\_id TO 45; GenValue GEN\_ID( gen\_stud\_id, 1);

Использование генераторов:

- В триггерах, процедурах.
- Для заполнения автоинкрементых полей.
- Для выдачи уникального номера клиентскому приложению.

**PROCEDURAL SQL**

**Триггеры**

Триггер – процедура обработки определенных событий на сервере.

**CREATE TRIGGER** <trigger\_name> **FOR** <table\_name> <trigger\_type> **POSITION** <pos\_value> **AS**

**BEGIN**

- // Тело триггера – набор SQL выражений разделяемых «;»

**END**

События – при операциях INSERT / DELETE / UPDATE.

Типы триггеров / событий:

- BEFORE DELETE; BEFORE INSERT; BEFORE UPDATE.
- AFTER DELETE; AFTER INSERT; AFTER UPDATE.

**PROCEDURAL SQL**

**Триггеры**

**NEW** и **OLD** – строка таблицы, над которой выполняется операция.

CREATE TRIGGER StudTrigger FOR Students BEFORE INSERT POSITION 0 AS

BEGIN

NEW.ID  GEN\_ID( gen\_stud\_id, 1);

END

Особенности триггеров:

- Триггер работает для одной таблицы.
- Таблица может иметь несколько триггеров.
- Можно обращаться к другим таблицам.
- Можно выполнять несколько запросов.
- Можно вызывать процедуры.

**PROCEDURAL SQL**

**Триггеры**

CREATE TRIGGER StudTrigger FOR Students BEFORE INSERT POSITION 0 AS

BEGIN

NEW.group\_id (SELECT FIRST 1 id FROM groups GROUP BY id);

END

Использование триггеров:

- Для заполнения полей при INSERT / UPDATE.
- Для контроля целостности.
- В целях отладки.

**PROCEDURAL SQL**

**Исключения**

Исключение – для обработки ошибок и выхода из процедур. **CREATE EXCEPTION** <имя\_искл> <сообщение> **EXCEPTION** <имя\_искл>

**WHEN EXCEPTION** < имя\_искл > **DO BEGIN**

- /\* Обработка исключения\*/

**END**

Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Исключения**

Системные исключения:

- Ошибки SQL
- Ошибки MS SQL Server

**WHEN** {**SQLSERVERCODE** | **SQLCODE**} <код\_ошибки> **DO BEGIN**

…

**END**

**WHEN ANY DO BEGIN**

…

**END**
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Хранимые процедуры**

ХП – позволяют выполнять один или несколько операторов SQL, могут иметь входные и выходные параметры.

**CREATE PROCEDURE** <имя\_ХП> ([<вх\_переменная1>, …]) **RETURNS** [<вых\_переменная1>, …]

**AS**

**DECLARE VARIABLE** [<внутр\_переменная>];

**BEGIN**

…

**END**


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**PROCEDURAL SQL**

**Хранимые процедуры**

Особенности процедур

- Несколько операторов SQL разделенных «;».
- Процедура может возвращать один или несколько наборов переменных.
- Вызов процедур внутри процедуры, рекурсия.

CREATE PROCEDURE group\_size (number VARCHAR(10))

RETURNS (scount INTEGER) AS

BEGIN

SELECT COUNT(\*) FROM groups, students WHERE students.group\_id groups.id AND  groups.number :number GROUP BY groups.id INTO :scount; SUSPEND;

END

**PROCEDURAL SQL**

**Хранимые процедуры**

Использование процедур

- Для реализация бизнес-логики на стороне сервера.
- Для реализации бизнес-логики не описываемой одним запросом.
- Вызов из процедур, триггеров и клиентского приложения.

**EXECUTE PROCEDURE** <имя\_проц> ([<параметр1,…>])

CREATE PROCEDURE fill\_avg\_mark AS

FOR SELECT id FROM students INTO :sid DO

BEGIN

UPDATE students SET avg\_mark = (SELECT avg(cast(mark as float)) FROM stud\_results WHERE student\_id : sid) WHERE id  : sid;

END

**PROCEDURAL SQL**

**Хранимые процедуры**

CREATE PROCEDURE check\_recurse RETURNS (recurse integer) AS

declare variable layer integer;

declare variable curr\_sbj integer;

declare variable root\_sbj integer;

BEGIN

recurse  0;

FOR SELECT subjects.id, ness\_subject\_id FROM subjects, subject\_rel WHERE subjects.id   subject\_rel.subject\_id INTO :root\_sbj, :curr\_sbj do BEGIN

layer  1;

EXECUTE PROCEDURE check\_subject(root\_sbj, curr\_sbj, layer);

WHEN EXCEPTION is\_recurse DO 

BEGIN

recurse  1;

break;

END

END

END

**PROCEDURAL SQL**

**Хранимые процедуры**

CREATE PROCEDURE check\_subject(root\_sbj integer, curr\_sbj integer, layer integer) AS

declare variable nid integer;

BEGIN

FOR SELECT ness\_subject\_id FROM subject\_rel WHERE subject\_id :curr\_sbj INTO :nid DO BEGIN

IF ((nid =root\_sbj) AND (layer < 10)) THEN

BEGIN

ECEPTION is\_recurse;

END

layer  layer + 1;

EXECUTE PROCEDURE check\_subject(:root\_sbj, :nid, :layer);

END

SUSPEND;

END

**PROCEDURAL SQL**

**Хранимые процедуры**

ХП может возвращать множество значений

CREATE PROCEDURE mvalues\_proc(number varchar(10))

RETURNS (id INT, fname varchar(20), lname varchar(20)) AS

BEGIN

FOR SELECT id, fname, lname FROM students, groups WHERE students.group\_id groups.id INTO :id, :fname, :lname DO BEGIN

…

SUSPEND;

END

END

**PROCEDURAL SQL**

**Хранимые процедуры**

Выбор одного (первого) набора данных:

EXECUTE PROCEDURE mvalues\_proc(‘4081/1’) RETURNING\_VALUES :id, :fname, :lname;

Выбор множества наборов данных:

FOR SELECT \* FROM mvalues\_proc(‘4081/1’) INTO :fname, :lname DO BEGIN

SUSPEND;

END

Вызов процедуры из запроса:

SELECT \* FROM mvalues\_proc(‘4081/1’) WHERE id > 10;

**PROCEDURAL SQL**

**События**

Событие – сообщение, которое БД посылаемые клиентам. **POST\_EVENT** <текст сообщения>

POST\_EVENT ‘It`s an event’;

DECLARE VARIABLE Message1 VARCHAR(20); Message1  ‘It`s an event’;

POST\_EVENT :Message1;

Выполнение действий по инициативе БД.


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 5. BCNF, 4NF, 5NF. Общая схема процедуры нормализации

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ПЕРЕКРЫВАЮЩИЕСЯ ПОТЕНЦИАЛЬНЫЕ КЛЮЧИ**

До сих пор в определениях нормальных форм мы предполагали, что у декомпозируемого отношения имеется только один возможный ключ. На практике чаще всего бывает именно так. Но имеется один частный случай, который почти удовлетворяет требованиям 3НФ, но, тем не менее, порождает аномалии обновления. Это тот случай, когда:

- имеется несколько потенциальных ключей у отношения;
- эти потенциальные ключи составные;
- некоторые из этих возможных ключей «перекрываются», т. е. содержат общие атрибуты (пересечение множеств атрибутов ПК1 и ПК2 не пусто).

**SSP![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.021.png)**



|**S#**|**SNAME**|**P#**|**QTY**|
| - | - | - | - |
|S1|Иванов|P1|300|
|S1|Иванов|P2|100|
|S1|Иванов|P3|200|
|S1|Иванов|P4|350|
|S1|Иванов|P5|400|
|S2|Петров|P3|300|
|…|…|…|…|


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ПЕРЕКРЫВАЮЩИЕСЯ ПОТЕНЦИАЛЬНЫЕ КЛЮЧИ**

Рассмотрим переменную-отношение  {S#, SNAME, P#, QTY}, предположим, что все поставщики имеют уникальные имена. Потенциальными ключами переменной-отношения являются пары атрибутов {S#, P#} и {SNAME, P#}, следовательно, имеются ФЗ {S#, P#} → SNAME, {S#, P#} → QTY и {SNAME, P#} → S#, {SNAME, P#} → QTY. Из того, что все имена поставщиков уникальны, следуют ФЗ S# → SNAME и SNAME → S#.

Переменная-отношение  находится в третьей нормальной форме (3НФ), все ФЗ неключевых атрибутов от возможных ключей являются неприводимыми и транзитивные ФЗ отсутствуют. Но, тем не менее, этому отношению свойственны аномалии обновления. Например, в случае изменения имени поставщика требуется обновить атрибут SNAME во всех кортежах переменной-отношения  , соответствующих данному поставщику. Иначе будет нарушена ФЗ S# → SNAME, и база данных окажется в несогласованном состоянии.

**НОРМАЛЬНАЯ ФОРМА БОЙСА-КОДДА**

Причиной отмеченных аномалий является то, что в 2НФ и 3НФ не требовалась неприводимая ФЗ от первичного ключа атрибутов, являющихся компонентами других потенциальных ключей. Проблему решает нормальная форма, которую исторически принято называть нормальной формой Бойса- Кодда и которая является уточнением 3НФ в случае наличия нескольких перекрывающихся потенциальных ключей.

Переменная отношения находится в **нормальной форме Бойса-Кодда** (НФБК или BCNF) в том и только в том случае, когда любая выполняемая для этой переменной отношения нетривиальная и неприводимая ФЗ имеет в качестве детерминанта некоторый потенциальный ключ данного отношения.

Для решения проблемы переменная-отношение  должна быть разделена на две проекции. Здесь существуют два варианта декомпозиции:

1 вариант

SS {S#, SNAME} SP {S#, P#, QTY}

2 вариант

SS {S#, SNAME}

SP {SNAME, P#, QTY}

Каждая из декомпозиций устраняет трудности, связанные с обновлением отношения.

**НОРМАЛЬНАЯ ФОРМА БОЙСА-КОДДА**

Пусть имеется переменная-отношение с атрибутами {S#, SNAME, STATUS, CITY}. Атрибуты S#, SNAME – потенциальные ключи переменной- отношения  . Атрибуты STATUS и CITY являются независимыми.

Переменная-отношение  находится в нормальной форме Бойса-Кодда, так как потенциальные ключи не перекрываются.

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.022.png)

**ВСЕГДА ЛИ СЛЕДУЕТ СТРЕМИТЬСЯ К НФБК?**

Рассмотрим еще один пример отношения с перекрывающимися потенциальными ключами. Пусть задана переменная отношение  , в которой хранится информация о студентах S, лекциях L и преподавателях T. Атрибуты отношения S, L и T. Кортеж (s,l,t) означает, что студент **s** слушает лекции **l** у преподавателя **t**. На информацию накладываются следующие ограничения:

1. Каждый студент S изучает предмет L только у одного преподавателя T.
1. Каждый преподаватель ведет только один предмет L, однако каждый предмет может преподаваться несколькими преподавателями.

Рассмотрим множество ФЗ переменной-отношения  . Из ограничения 1 следует ФЗ {S, L} → {T}, из ограничения 2 – ФЗ {T} → {L}.

**SLT![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.023.png)**



|**S**|**L**|**T**|
| - | - | - |
|Алешин|Мат. анализ|Пр. Иванов|
|Борисов|Лин. алгебра|Пр. Петров|
|Васькин|Мат. анализ|Пр. Иванов|
|Гришин|Лин. алгебра|Пр. Сидоров|
**ВСЕГДА ЛИ СЛЕДУЕТ СТРЕМИТЬСЯ К НФБК?**

В этом отношении существуют два перекрывающихся потенциальных ключа: комбинация {S, L} и комбинация {S, T} ({T} → {L} ⇒ {S,T} → {S,L} ⇒ {S,T} → {L}). Переменная отношение  удовлетворяет требованиям 3НФ: все ФЗ неключевых атрибутов от возможных ключей являются неприводимые (не ключевых атрибутов просто нет) и отсутствуют транзитивные ФЗ. Однако, из-за наличия ФЗ {T} → {L} это отношение не находится в НФБК. Поэтому отношению  снова свойственны аномалии обновления. Например, поскольку S является компонентом обоих возможных ключей, невозможно удалить данные о студенте Гришине, не утратив информацию о том, что пр. Сидоров преподает линейную алгебру. Эти трудности вызваны тем, что атрибут T является детерминантом ФЗ {T} → {L}, но не является потенциальным ключом (T входит в состав потенциального ключа).

Можно привести исходную переменную-отношение  к НФБК, выполнив его декомпозицию на две проекции  {S,T} и  {T,L}. Эта декомпозиция решает указанные проблемы, теперь можно хранить данные о преподавателе, не читающем в данный момент ни одной лекции.

**ST TL![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.024.png)**



|**S**|**T**|
| - | - |
|Алешин|Пр. Иванов|
|Борисов|Пр. Петров|
|Васькин|Пр. Иванов|
|Гришин|Пр. Сидоров|

|**T**|**L**|
| - | - |
|Пр. Иванов|Мат. анализ|
|Пр. Петров|Лин. алгебра|
|Пр. Сидоров|Лин. алгебра|
**ВСЕГДА ЛИ СЛЕДУЕТ СТРЕМИТЬСЯ К НФБК?**

Однако возникают новые трудности. Две проекции  и  , полученные при декомпозиция исходного отношения, не являются независимыми. Функциональная зависимость {S, L} → {T} не может быть выведена из единственной (нетривиальной) действующей для этих проекций ФЗ {T} → {L}, и соответствующее ограничение целостности становится ограничением базы данных. В результате две полученные проекции не могут обновляться независимо. Например, кортеж (Борисов, Пр. Сидоров) противоречит ограничению 1 (каждый студент изучает определенный предмет только у одного преподавателя). Пр. Сидоров читает лекции по линейной алгебре, а студент Борисов уже изучает линейную алгебру у пр. Петрова. Но обнаружить этот факт можно только проверив содержимое переменной-отношения  . Проекции  и  не являются независимыми, а отношение  – атомарно, хотя и не находится в НФБК.

Попытка достижения двух целей, декомпозиции исходной переменной-отношения на переменные-отношения, находящиеся в НФБК, и декомпозиции исходной переменной-отношения  на независимые компоненты, может привести к конфликтной ситуации. Из этого следует, что при проектировании реляционной базы данных приведение отношения к НФБК не должно быть самоцелью. Нужно внимательно оценивать положительные и отрицательные последствия нормализации.

**ВСЕГДА ЛИ СЛЕДУЕТ СТРЕМИТЬСЯ К НФБК?**

Рассмотрим пример, когда наличие двух перекрывающихся возможных ключей не мешает отношению находиться в НФБК. Задана переменная-отношение 

с атрибутами S (студент), L (предмет), P (позиция). Каждый кортеж (s, l, p) означает, что студент **s** экзаменуется по предмету **l** и занимает позицию **p** в экзаменационной ведомости. Имеет место ограничение, что никакие два студента не могут занимать одну и ту же позицию в экзаменационной ведомости по одному и тому же предмету. В этом примере имеются перекрывающиеся возможные ключи {S, L} и {L, P}, поскольку для каждого студента и предмета существует точно одна занимаемая позиция в ведомости, а в каждой ведомости по некоторому предмету каждую позицию занимает только один соответствующий студент. Однако эта переменная-отношение находится в НФБК, поскольку эти ключи являются единственными детерминантами. Легко убедиться, что отношению  аномалии обновления не свойственны.

При проектировании реляционной базы данных почти всегда добиваются представления во второй нормальной форме всех входящих в базу данных отношений. В часто обновляемых базах данных обычно стараются обеспечить третью нормальную форму отношений. Нормальную форму Бойса-Кодда используют гораздо реже, поскольку на практике ситуации, в которых у отношения имеется несколько составных перекрывающихся потенциальных ключей, встречаются нечасто.

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.025.png)

**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Четвертая нормальная форма касается отношений, в которых имеются повторяющиеся наборы данных. Декомпозиция, основанная на ФЗ, не приводит к исключению такой избыточности. В этом случае используют декомпозицию, основанную на многозначных зависимостях (МЗЗ).

Многозначная зависимость является обобщением функциональной зависимости и рассматривает соответствия между множествами значений атрибутов. В качестве примера рассмотрим переменную-отношение ПРЕПОДАВАТЕЛЬ\_ОБЩ (ИМЕНА, КУРСЫ, УЧЕБНОЕ\_ПОСОБИЕ), хранящее сведения о курсах, читаемых преподавателем, и используемых им учебниках.

Пусть профессор Иванов читает курс «Линейная алгебра» и использует следующие учебные пособия: «Линейная алгебра» (авторы Крищенко А.П., Канатников А.Н.) и «Линейная алгебра» (автор Воеводин В.В.). Профессор Сидоров читает курс «Математический анализ» и использует учебники «Курс математического анализа» (автор Кудрявцев Л.Д.) и «Курс дифференциального и интегрального исчисления» (автор Фихтенгольц Г.М.). Сидоров также может читать курс «Линейная алгебра».

- Каждый кортеж переменной-отношения ПРЕПОДАВАТЕЛЬ\_ОБЩ состоит из атрибутов названия курса КУРС, атрибута-отношения ИМЯ с именами преподавателей и атрибута-отношения УЧЕБНОЕ\_ПОСОБИЕ с названиями учебников.
- Соответствующий курс может преподаваться любым из указанных преподавателей с использованием всех указанных учебников.
- Для заданного курса может быть определено произвольное количество соответствующих преподавателей и учебников.
- Преподаватели и учебники независимы друг от друга, т.е. независимо от того, кто преподает данный курс, всегда используется один и тот же стандартный набор учебников.
- Определенный преподаватель или определенный учебник может быть связан с любым количеством курсов.

**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Для дальнейшей работы с отношением ПРЕПОДАВАТЕЛЬ\_ОБЩ, необходимо исключить атрибуты, принимающие в качестве значений отношения, т.е. привести отношение в 1НФ. Заменим переменную-отношение ПРЕПОДАВАТЕЛЬ\_ОБЩ (ИМЕНА, КУРСЫ, УЧЕБНОЕ\_ПОСОБИЕ) переменной- отношением ПРЕПОДАВАТЕЛЬ (ИМЯ, КУРС, УЧЕБНИК) с тремя скалярными атрибутами. Из каждого кортежа исходной переменной-отношения ПРЕПОДАВАТЕЛЬ\_ОБЩ получаем  ∗ кортежей в переменной-отношении ПРЕПОДАВАТЕЛЬ, где  и  количество строк в отношениях ИМЯ и УЧЕБНИК. Все атрибуты результирующей переменной-отношения ПРЕПОДАВАТЕЛЬ входят в состав ключа. В переменной-отношении ПРЕПОДАВАТЕЛЬ\_ОБЩ ключ состоял из одного атрибута КУРСЫ.

**ПРЕПОДАВАТЕЛЬ**



|**КУРС**|**ИМЯ**|**УЧЕБНИК**|
| - | - | - |
|Линейная алгебра|Иванов|«Линейная алгебра» Крищенко А.П., Канатников А.Н.|
|Линейная алгебра|Иванов|«Линейная алгебра» Воеводин В.В.|
|Линейная алгебра|Сидоров|«Линейная алгебра» Крищенко А.П., Канатников А.Н.|
|Линейная алгебра|Сидоров|«Линейная алгебра» Воеводин В.В.|
|Математический анализ|Сидоров|«Курс математического анализа» Кудрявцев Л.Д.|
**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Данные, помещаемые в переменную-отношение ПРЕПОДАВАТЕЛЬ, имеют следующий смысл: кортеж (КУРС:к, ИМЯ:и, УЧЕБНИК:у) появляется в переменной-отношении ПРЕПОДАВАТЕЛЬ тогда и только тогда, когда курс **к** читается преподавателем **и** с использованием учебника **у**. Для каждого курса указаны все возможные комбинации имени преподавателей (и1, и2) и названий учебников (у1, у2). Тогда, можно утверждать, что для переменной- отношения ПРЕПОДАВАТЕЛЬ верно следующее ограничение:

ЕСЛИ кортежи (к, и1, у1) и (к, и2, у2) присутствуют одновременно, ТО кортежи (к, и1, у2) и (к, и2, у1) также присутствуют одновременно.

Очевидно, что переменная-отношение ПРЕПОДАВАТЕЛЬ характеризуется значительной избыточностью, вследствие чего возникнут аномалии обновления. Например, для добавления информации о том, что курс линейной алгебры может читаться новым преподавателем, необходимо создать два новых кортежа, по одному для каждого используемого учебника. Рассматриваемые проблемы возникают в результате того, что преподаватели и учебники не зависят друг от друга. Улучшить ситуацию можно, выполнив декомпозицию переменной-отношения ПРЕПОДАВАТЕЛЬ на две проекции К\_ИМЯ с атрибутами {КУРС, ИМЯ} и К\_УЧЕБНИК с атрибутами {КУРС, УЧЕБНИК}.

**К\_ИМЯ К\_УЧЕБНИК**



|**КУРС**|**ИМЯ**|
| - | - |
|Линейная алгебра|Иванов|
|Линейная алгебра|Сидоров|
|Математический анализ|Сидоров|

|**КУРС**|**УЧЕБНИК**|
| - | - |
|Линейная алгебра|«Линейная алгебра» Крищенко А.П., Канатников А.Н.|
|Линейная алгебра|«Линейная алгебра» Воеводин В.В.|
|Математический анализ|«Курс математического анализа» Кудрявцев Л.Д.|
**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Переменная-отношение ПРЕПОДАВАТЕЛЬ может быть восстановлена за счет обратного соединения проекций К\_ ИМЯ и К\_УЧЕБНИК, т.е. данная декомпозиция была выполнена без потерь. В этом случае для добавления новой информации о том, что курс математического анализа будет читаться новым преподавателем, достаточно вставить единственный кортеж в переменную-отношение К\_ ИМЯ. Можно было бы предположить, что для переменных-отношений, подобных ПРЕПОДАВАТЕЛЬ, существует некий способ «дальнейшей нормализации». С неформальной точки зрения переменная-отношение ПРЕПОДАВАТЕЛЬ спроектирована плохо и ее декомпозиция на проекции К\_ИМЯ и К\_ УЧЕБНИК является более удачным решением. Переменная-отношение ПРЕПОДАВАТЕЛЬ вообще не имеет функциональных зависимостей (за исключением таких тривиальных, как КУРС 

- КУРС), поэтому ранее обсуждавшиеся принципы нормализации здесь неприменимы, но, тем не менее, мы получили полезную декомпозицию. Фактически переменная-отношение ПРЕПОДАВАТЕЛЬ находится в НФБК, поскольку, все ее атрибуты входят в состав ее ключа. Обе ее проекции К\_ИМЯ и К\_УЧЕБНИК также являются полностью ключевыми и находятся в НФБК.

В переменной-отношения ПРЕПОДАВАТЕЛЬ существует новый вид зависимости. Р. Фейджин (R. Fegin) в 1971 г. назвал зависимости этого вида многозначными или МЗЗ (multi-valued dependency – MVD в англоязычной литературе). Аномалии обновления переменной-отношения ПРЕПОДАВАТЕЛЬ связаны с наличием в ней МЗЗ. В ней есть две многозначные зависимости:

КУРС →→ ИМЯ

КУРС →→ УЧЕБНИК

Обозначение «→→» в многозначной зависимости А →→ В означает, что В многозначно зависит от А или А многозначно определяет В.

**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Первая из этих зависимостей, КУРС →→ ИМЯ, означает, что, хотя для каждого курса не существует одного соответствующего только ему преподавателя, т.е. не выполняется ФЗ КУРС → ИМЯ, каждый курс имеет вполне определенное множество соответствующих преподавателей. «Вполне определенное множество» означает, что для данного курса *к* и данного учебника *у* множество преподавателей *и*, соответствующее паре (к, у) переменной-отношения ПРЕПОДАВАТЕЛЬ, зависит от значения *к* и совершенно не зависит от значения *у*. Вторую МЗЗ КУРС →→ УЧЕБНИК можно интерпретировать аналогично.

Из классической теории отношений известно понятие соответствия из множества **A** во множество **B**, когда одному элементу множества **A** может сопоставляться несколько элементов множества B. Понятие соответствие обобщает понятие функциональной зависимости между множествами **A** и **B**. В реляционной теории возникает ситуация, когда устанавливается соответствие из множества атрибутов **A** во множество атрибутов **B** и из множества атрибутов **A** во множество атрибутов **C**. При этом множества **B** и **C** между собой независимы. Применим к отношению  (A, B, C) операцию ограничения (выборки), где условием ограничения является равенство значений атрибута **A** некоторому заданному значению **a**. По аналогии с теорией отношений, назовем такую выборку сечением по атрибуту **a** (результатом применения операции ограничения, заданного условием **p**, к отношению **A** является отношение с тем же заголовком, что и у отношения **A**, тело которого состоит из таких кортежей, для которых условие **p** выполняется при подстановке в него значения атрибутов этого кортежа).

**Сечением** отношения  с атрибутами A, B, C по значению **a** атрибута A называется отношение  (R, a), заголовок которого совпадает с заголовком отношения  и телом, состоящим из кортежей (a, x, y), таких, что  ∈ ,  ∈ и ( , , ) ∈ .

Пусть A, B и C являются произвольными подмножествами множества атрибутов переменной-отношения  . Подмножество B **многозначно зависит** от подмножества A (А →→ В), в том и только в том случае, когда множество значений атрибута B, соответствующее заданной паре значений атрибутов A и C переменной-отношения  , зависит от значения A, но не зависит от значения С.

∀ ∈ , , = , ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.026.png) , ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.027.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.028.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.029.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.030.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.031.png)

((( , , ) ∈ ) (( , , ) ∈ )) ((( , , ) ∈ ) (( , , ) ∈ ))

**МНОГОЗНАЧНЫЕ ЗАВИСИМОСТИ**

Многозначные зависимости обладают свойством «двойственности».

**Лемма Фейджина**

Для переменной-отношения  {А, B, C} многозначная зависимость A →→ B выполняется тогда и только тогда, когда выполняется многозначная зависимость A →→ С.

Таким образом, многозначные зависимости всегда образуют связанные пары, поэтому обычно их представляют вместе в виде A →→ B | С. Для рассматриваемого примера такая запись будет иметь следующий вид КУРС →→ ИМЯ | УЧЕБНИК. Многозначные зависимости являются обобщениями функциональных зависимостей. Функциональная зависимость – это многозначная зависимость, в которой множество зависимых значений (значений атрибутов, а не самих атрибутов), соответствующее заданному значению детерминанта, всегда является одноэлементным множеством. Обратное утверждение неверно, поскольку существуют многозначные зависимости, которые не являются функциональными. Таким образом, если A → B, то A →→ В. Проблема с переменными-отношениями, аналогичными отношению ПРЕПОДАВАТЕЛЬ возникает из-за того, что они содержат многозначные зависимости, которые не являются функциональными. Именно наличие таких МЗЗ требует вставки двух кортежей, когда необходимо добавить сведения о новом преподавателе. Два кортежа необходимы для поддержания ограничения целостности, представленного этой МЗЗ. Проекции К\_ИМЯ и К\_УЧЕБНИК не содержат многозначных зависимостей, а потому они действительно представляют собой некоторое усовершенствование исходной структуры. Исходную переменную-отношение ПРЕПОДАВАТЕЛЬ желательно заменить двумя рассматриваемыми проекциями.

**Теорема Фейджина**

Пусть А, В и С являются множествами атрибутов переменной-отношения  {А, В, С}. Переменная-отношение  будет равна соединению ее проекций [А, В] и [А, С] тогда и только тогда, когда для переменной-отношения  выполняется многозначная зависимость А →→ В | С.

- , , ⇔ для переменной − отношения выполняется зависимость А →→ В | С![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.032.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.033.png)

**ЧЕТВЕРТАЯ НОРМАЛЬНАЯ ФОРМА**

Теорема Фейджина обеспечивает основу для декомпозиции отношений, удаляющей «аномальные» многозначные зависимости, с приведением отношений в четвертую нормальную форму.

Переменная отношения  находится в четвертой нормальной форме (4НФ) в том и только в том случае, когда она находится в НФБК, и все МЗЗ являются ФЗ с детерминантами – потенциальными ключами отношения  . Иначе говоря, в переменной-отношении  могут находиться только нетривиальные зависимости (функциональные или многозначные) вида K → X, т.е. некоторый атрибут X функционально зависит от суперключа К. МЗЗ А →→ В называется тривиальной, если либо А является супермножеством В, либо объединение А и В образует весь заголовок отношения.

**Эквивалентное определение 4НФ**:

Отношение находится в 4НФ, если оно находится в НФБК и в нем отсутствуют многозначные зависимости, не являющиеся функциональными зависимостями.

Нахождение в 4НФ предполагает обязательное нахождение в НФБК. Переменная-отношение ПРЕПОДАВАТЕЛЬ не находится в 4НФ, поскольку содержит многозначную зависимость, которая не является функциональной. Однако обе ее проекции, К\_ИМЯ и К\_УЧЕБНИК , находятся в 4НФ. Следовательно, 4НФ обеспечивает лучшую структуру данных по сравнению с НФБК, поскольку позволяет исключить некоторые нежелательные зависимости. Фейджин показал, что 4НФ всегда является достижимой, т.е. любая переменная-отношение может быть подвергнута декомпозиции без потерь в эквивалентный набор переменных-отношений в 4НФ. Однако 4НФ не всегда оказывается полезной и нужной.

**ЧЕТВЕРТАЯ НОРМАЛЬНАЯ ФОРМА**

Рассмотрим процедуру исключения атрибутов, принимающих в качестве значений отношения, или АО (атрибутов-отношений). На практике для достижения 4НФ достаточно учитывать следующее: если мы имеем дело с переменной-отношением с двумя или более независимыми АО, то, прежде всего, следует разделить эти АО.

Например, в случае переменной-отношения ПРЕПОДАВАТЕЛЬ\_ОБЩ прежде всего следует заменить исходную переменную-отношение двумя ее проекциями К\_ИМЯ {КУРС, ИМЕНА} и К\_УЧЕБНИК {КУРС, УЧЕБНЫЕ\_ПОСОБИЯ}, где переменные-отношения ИМЕНА и УЧЕБНЫЕ\_ПОСОБИЯ все еще сохраняют АО. Далее эти АО можно будет исключить из двух полученных проекций (с приведением их к НФБК) обычным способом, и тогда аномалии обновления, свойственные переменной-отношению ПРЕПОДАВАТЕЛЬ, находящейся в НФБК, просто никогда не возникнут. Понятия МЗЗ и 4НФ предоставляют формальное обоснование тех правил, которые в противном случае остались бы чисто эмпирическими.

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Приведение отношения к 4NF предполагает его декомпозицию без потерь на две проекции (как и в случае 2NF, 3NF и BCNF). Однако бывают (хотя и нечасто) случаи, когда декомпозиция без потерь на две проекции невозможна, но можно произвести декомпозицию без потерь на три или более проекций. Будем называть  -декомпозируемым отношением отношение, которое может быть декомпозировано без потерь на  проекций. Подобные переменные- отношения обозначим не очень удачным, но достаточно удобным термином « -декомпозируемая переменная-отношение» (для некоторого  > ). До сих пор мы имели дело с - декомпозируемыми отношениями.

Рассмотрим переменную-отношение  из базы данных поставщиков, деталей и проектов. Переменная-отношение  состоит только из ключевых атрибутов, не содержит нетривиальных функциональных и многозначных зависимостей и потому находится в 4НФ.

**SPJ SP![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.034.png)**

|**S#**|**P#**|**J#**|
| - | - | - |
|S1|P1|J2|
|S1|P2|J1|
|S2|P1|J1|
|S1|P1|J1|
![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.035.png) ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.036.png)

**SJ PJ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.037.png)**

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

На рисунке показаны следующие компоненты:

1. Три бинарные проекции,  ,  и  , переменной-отношения  .
1. Результат соединения проекций  и по атрибуту Р#.
1. Соединение этого результата с проекцией  по комбинации атрибутов {J#, S#}.

В результате первого соединения получается копия исходной переменной-отношения с одним дополнительным (излишним) кортежем, а в результате второго соединения этот лишний кортеж исключается. Иначе говоря, исходная переменная-отношение  является 3-декомпозируемой.

**SP PJ JS![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.038.png)**

Соединяем по![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.039.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.040.png)

|**S#**|**P#**|
| - | - |
|S1|P1|
|S1|P2|
|S2|P1|

|**P#**|**J#**|
| - | - |
|P1|J2|
|P2|J1|
|P1|J1|

|**J#**|**S#**|
| - | - |
|J2|S1|
|J1|S1|
|J1|S2|
атрибуту P#

**SPJ ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.041.png)**



|**S#**|**P#**|**J#**|
| - | - | - |
|S1|P1|J2|
|S1|P1|J1|
|S1|P2|J1|
|S2|P1|J2|
|S2|P1|J1|
Соединяем по ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.042.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.043.png) комбинации 

атрибутов J# и S#

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.044.png) Исходное отношение ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.045.png)

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Представленный пример выполнен в терминах отношений, а не переменных-отношений. Однако 3-декомпозируемость переменной-отношения  может быть более фундаментальным и не зависящим от времени свойством (т.е. свойством, которое удовлетворяется для всех допустимых значений данной переменной-отношения), если данная переменная-отношение удовлетворяет определенному не зависящему от времени ограничению целостности.

Заметим, что утверждение «переменная-отношение  равна соединению трех своих проекций  , и  » в точности эквивалентно следующему утверждению.

ЕСЛИ пара , присутствует в И пара , присутствует в ,![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.046.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.047.png)

И пара ( , ) присутствует в ,ТО тройка ( , , ) присутствует в .

(( , ) ∈ & (, ) ∈ & ( , ) ∈ ) ⇒ ( , , ) ∈

Это верно, потому, что тройка (s1,p1,j1) обязательно присутствует в соединении проекций SP,JS и PJ. Верно и обратное

( ,, ) ∈ ⇒ (( , ) ∈ & (, ) ∈ & ( , ) ∈ ) То есть можно записать 

(( ,) ∈ & ( , ) ∈ & ( , ) ∈ ) ⇔ ( , , ) ∈

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Так как пара (s1,p1) присутствует в отношении  тогда и только тогда, когда тройка (s1,p1,j2) присутствует в отношении  для некоторого значения j2 (аналогично для (р1,j1) и (j1,s1)), приведенное выше утверждение можно переписать в виде ограничения, накладываемого на переменную-отношение  .

ЕСЛИ кортежи ( ,, ),( , , ),( ,р , ) присутствуют в ТО кортеж ( ,р , ) также присутствует в ({( ,, ),( ,, ),( ,р , )} ∈ ) ⇒ ( , , ) ∈

Если это утверждение выполняется всегда, т.е. для всех допустимых значений переменной-отношения  , то будет получено не зависящее от времени ограничение для данной переменной-отношения. Это ограничение имеет **циклическую структуру** («если значение s1 связано с p1 и p1 связано с j1, а j1 связано опять с s1, то s1, p1 и j1 должны находиться в одном кортеже»), и называется 3-декомпозируемым ограничение (ЗД-ограничением).

**Определение**. Переменная-отношение будет  -декомпозируемой для  > в том и только в том случае, когда она удовлетворяет некоторому циклическому ограничению.

Предположим теперь, что переменная-отношение  действительно удовлетворяет этому не зависящему от времени ограничению. Что означает ЗД- ограничение с практической точки зрения?

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Рассмотрим пример, в котором под такими ограничениями подразумевается следующее: если в реальном мире для переменной-отношения  верны утверждения

1) Смит поставляет гаечные ключи,
1) Гаечные ключи используются в Манхэттенском проекте,
1) Смит является поставщиком для Манхэттенского проекта,

то

4) Смит поставляет гаечные ключи для Манхэттенского проекта.

Обычно из взятых в совокупности утверждений **a**, **b** и **c** не следует утверждение **d**. Но поскольку существует дополнительное ЗД-ограничение, имеющее место в реальном мире, вывод утверждения **d**, основанный на утверждениях **a**, **b** и **c** является вполне правомочным.

ЗД-ограничение называется **зависимостью соединения** (ЗС), поскольку ЗД-ограничение удовлетворяется тогда и только тогда, когда переменная- отношение равносильна соединению некоторых ее проекций. Зависимость соединения является таким же ограничением для данной переменной- отношения, как многозначная и функциональная зависимости.

Пусть задана переменная отношения  , и  , ,…, являются произвольными подмножествами заголовка R (составными, перекрывающимися атрибутами).

**Определение**. Переменная-отношение удовлетворяет зависимости соединения ∗ { , ,… , } в том и только в том случае, когда любое допустимое значение переменной-отношения  эквивалентно соединению ее проекций на атрибуты  , ,… , . Зависимость соединения в англоязычной литературе называется зависимостью проекции/соединения **Project-Join Dependency – PJD**.

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Если переменная-отношение удовлетворяет зависимости соединения, то наличие зависимости соединения в переменной-отношения  характеризуется многочисленными аномалиями обновления, которые можно устранить лишь с помощью 3-декомпозиции. Переменная-отношение  будет удовлетворять зависимости соединения ∗ { , , }. Следовательно переменная-отношение  с зависимостью соединения ∗ { , , } может быть 3-декомпозируемой.

**Проекции SPJ SPJ SPJ**

|**SP**|**PJ**|**JS**|
| - | - | - |
|S1P1|P1J2|J2S1|
|S1P2|P2J1|J1S1|
|S2P1|P1J1|J1S2|
|S1P1|P1J1|J1S1|

|**S#**|**P#**|**J#**|
| - | - | - |
|S1|P1|J2|
|S1|P2|J1|
|S2|P1|J1|
|S1|P1|J1|

|**S#**|**P#**|**J#**|
| - | - | - |
|S1|P1|J2|
|S1|P2|J1|
- Если вставляется кортеж(S2,Р1,J1), то также  • Кортеж (S2,Р1,J1) может бытьудален без должен бытьвставлен кортеж (S1,Р1,J1) побочных эффектов

(∃(, ) & ∃(Р , )& ∃(, ) ⇒ ∃(, , )) • Если удаляется кортеж(S1,Р1,J1), то также 

- Обратное утверждение не является истинным долженбыть удален еще один кортеж

**ЗАВИСИМОСТИ СОЕДИНЕНИЯ**

Заметим, что в примере необходимость вставки кортежа (S2,Р1,J1) вместе кортежем (S1,Р1,J1) обусловлено зависимостью соединения. Поскольку значение S1связано с Р1 (строка 1)и Р1 связано с J1(вставляемая строка), а J1 связано опять с S1 (строка 2), то S1, P1 и J1 должны находиться в одном кортеже. В случае удаления кортежа (S1,Р1,J1) быть удален еще кортеж (S2,Р1,J1), т.к. значения Р1 с J1 не связаны больше ни в одном кортеже.

Теорема Фейджина утверждает, что переменная-отношение  {А, В, С} может быть декомпозирована без потерь на проекции с атрибутами {А, В} и {А, С} тогда и только тогда, когда для переменной-отношения выполняются многозначные зависимости А →→ В и А →→ С. Теперь теорему Фейджина можно сформулировать иначе.

Переменная-отношение  {А, В, С} удовлетворяет зависимости соединения ∗ { , } тогда и только тогда, когда она удовлетворяет многозначной зависимости А →→ В | С.

→→ | ⇔ ∗ { , }

Зависимость соединения является обобщением понятия многозначной зависимости. Из определения зависимости соединения следует, что из всех возможных форм это наиболее общая форма зависимости. Это значит, что для переменных-отношений, которые подвергаются декомпозиции на проекции и обратной композиции с соединением проекций, не существует более высокой степени зависимости, по отношению к которой зависимость соединения является всего лишь частным случаем.

Переменная-отношение SPJ содержит зависимость соединения, которая не является ни многозначной, ни функциональной. Желательно декомпозировать такую переменную-отношение на меньшие компоненты, а именно – на проекции, определяемые зависимостью соединения. Данный процесс декомпозиции может повторяться до тех пор, пока все результирующие переменные-отношения не будут находиться в пятой нормальной форме.

**ПЯТАЯ НОРМАЛЬНАЯ ФОРМА**

Переменная-отношение  находится в пятой нормальной форме (5НФ), или проекционно-соединительной нормальной форме (ПСНФ), в том и только в том случае, когда каждая нетривиальная зависимость соединения в переменной-отношении  определяется ее потенциальными ключами. Зависимость соединения ∗ { , ,…, } в переменной отношения  называется тривиальной, если хотя бы один из составных атрибутов  , ,…, совпадает с заголовком  .

Заданная зависимость соединения ∗ { , ,…, } определяется потенциальными ключами тогда и только тогда, когда каждое подмножество атрибутов 

, ,…, фактически является суперключом для данной переменной-отношения. Другими словами, каждая проекция такого отношения содержит не менее одного потенциального ключа и не менее одного неключевого атрибута. Фейджин показал, что любая МЗЗ, определяемая потенциальным ключом, является ФЗ, в которой потенциальный ключ является детерминантом. Любая переменная-отношение может быть подвергнута декомпозиции без потерь на эквивалентный набор переменных-отношений в 5НФ, т.е. 5НФ всегда достижима.

Любая переменная-отношение в 5НФ автоматически находится в 4НФ. Отношение находится в 4НФ, если оно находится в НФБК и в нем отсутствуют многозначные зависимости, не являющиеся функциональными зависимостями. Переменная-отношение  не находится в 5НФ. Она удовлетворяет зависимости соединения (ЗД-ограничению), которая не определяется ее единственным потенциальным ключом (этот ключ является комбинацией всех ее атрибутов). Переменная-отношение может быть 3-декомпозирована. После 3-декомпозиции проекции  ,  и  находятся в 5НФ, поскольку в них нет нетривиальных зависимостей соединения.

**ПЯТАЯ НОРМАЛЬНАЯ ФОРМА**

Таким образом, для заданной переменной-отношения можно утверждать, что она находится в 5НФ, только при условии, что известны все ее потенциальные ключи и все зависимости соединения, существующие в ней. Однако в отличие от ФЗ и МЗЗ (для которых обычно существует вполне очевидное обоснование в реальном мире) обнаружить все зависимости соединения совсем непросто. Смысловое значение зависимостей соединения, которые не являются одновременно МЗЗ и ФЗ, далеко не всегда очевидно. Следовательно, процедура определения того, что некоторая переменная- отношение все еще находится в 4НФ, а не в 5НФ, и, существует возможность ее дальнейшей выгодной декомпозиции, все еще остается не вполне ясной. Однако подобные переменные-отношения достаточно экзотичны и чрезвычайно редко встречаются на практике.

Заметим, что, как следует из определения, 5НФ является окончательной нормальной формой по отношению к операциям проекции и соединения (что отражено в ее альтернативном названии – проекционно-соединительная нормальная форма). Таким образом, если переменная-отношение находится в 5НФ, то гарантируется, что она не содержит аномалий, которые могут быть исключены посредством ее разбиения на проекции. Если переменная- отношение находится в 5НФ, то единственными в ней являются те зависимости соединения, которые определяются ее потенциальными ключами, и тогда единственными допустимыми декомпозициями будут декомпозиции, которые основаны на этих потенциальных ключах (каждая проекция в подобной декомпозиции будет состоять из одного или нескольких потенциальных ключей плюс нуль или более дополнительных атрибутов).

**ПЯТАЯ НОРМАЛЬНАЯ ФОРМА**

Рассмотрим переменную-отношение  поставщиков с потенциальными ключами S# и SNAME. Такая переменная-отношение удовлетворяет нескольким зависимостям соединения, в частности следующей зависимости ∗ {{ #, , },{ #, }}. Это значит, что переменная-отношение равносильна соединению ее проекций с атрибутами {S#, SNAME, STATUS} и {S#, CITY}. Поэтому она может быть подвергнута декомпозиции без потерь на указанные проекции. Заметим, что ее не следует, а лишь можно подвергать подобной декомпозиции. Существование данной зависимости соединения предполагается на основании того факта, что атрибут {S#} является потенциальным ключом данной переменной-отношения (в действительности это следует из теоремы Хита).

Аналогично переменная-отношение  удовлетворяет еще одной зависимости соединения ∗ {{ #, },{ #, },{ , }}. Эта зависимость следует из того, что оба атрибута, {S#} и {SNAME}, являются потенциальными ключами.

Как следует из приведенного выше примера, заданная зависимость соединения ∗ { , ,…, } определяется потенциальными ключами тогда и только тогда, когда каждое подмножество атрибутов  , ,…, фактически является суперключом для данной переменной-отношения. Например, переменная- отношение поставщиков  находится в 5НФ. Эта переменная-отношение может быть подвергнута дальнейшей декомпозиции без потерь, причем в нескольких вариантах, но каждая проекция в любом из этих вариантов по-прежнему будет содержать один из исходных потенциальных ключей. Следовательно, подобная декомпозиция не даст никаких дополнительных преимуществ.

**ОБЩАЯ СХЕМА ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ**

Пусть дана некоторая переменная-отношение  , представленная в 1НФ, в совокупности с набором определенных для нее функциональных зависимостей, многозначных зависимостей и зависимостей соединения. Задача нормализации заключается в систематическом разбиении исходной переменной- отношения  на набор меньших (т.е. имеющих меньшую степень) переменных-отношений, который в некотором заданном смысле будет эквивалентен  , но будет более предпочтительным.

Каждый этап процесса нормализации заключается в разбиении на проекции переменных-отношений, полученных на предыдущем этапе. При этом на каждом этапе нормализации существующие ограничения используются для выбора тех проекций, которые будут получены в этот раз (на данном шаге). Весь процесс можно определить с помощью следующих правил.

1. Переменную-отношение в 1НФ следует разбить на такие проекции, которые позволят исключить все функциональные зависимости, не являющиеся неприводимыми. В результате будет получен набор переменных-отношений в 2НФ.
1. Полученные переменные-отношения в 2НФ следует разбить на такие проекции, которые позволят исключить все существующие транзитивные функциональные зависимости. В результате будет получен набор переменных-отношений в ЗНФ.
1. Полученные переменные-отношения в ЗНФ следует разбить на проекции, позволяющие исключить любые оставшиеся функциональные зависимости, в которых детерминанты не являются потенциальными ключами. В результате такого приведения будет получен набор переменных-отношений в НФБК.
1. Полученные переменные-отношения в НФБК следует разбить на проекции, позволяющие исключить любые многозначные зависимости, не являющиеся функциональными. В результате будет получен набор переменных-отношений в 4НФ.
1. Полученные переменные-отношения в 4НФ следует разбить на проекции, позволяющие исключить любые зависимости соединения, которые не определяются потенциальными ключами. В результате будет получен набор переменных-отношений в 5НФ.

**ОБЩАЯ СХЕМА ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ**

Замечания:

1. Правила 1-3 могут быть объединены в одно: «Исходную переменную-отношение следует разбить на проекции, позволяющие исключить все функциональные зависимости, в которых детерминанты не являются потенциальными ключами».
1. На практике такие многозначные зависимости обычно исключаются перед выполнением этапов 1-3.
1. Процесс разбиения на проекции на каждом этапе должен быть выполнен без потерь и с сохранением зависимостей (там, где это возможно).
1. Существует набор следующих альтернативных определений НФБК, 4НФ и 5НФ:
- Переменная-отношение  находится в НФБК тогда и только тогда, когда каждая функциональная зависимость определяется ее потенциальными ключами.
- Переменная-отношение  находится в 4НФ тогда и только тогда, когда каждая многозначная зависимость определяется ее потенциальными ключами.
- Переменная-отношение  находится в 5НФ тогда и только тогда, когда каждая зависимость соединения определяется ее потенциальными ключами.

Аномалии обновления, обсуждавшиеся ранее, были вызваны именно теми функциональными зависимостями, многозначными зависимостями или зависимостями соединения, которые не определялись потенциальными ключами.

**ОБЩЕЕ НАЗНАЧЕНИЕ ПРОЦЕССА НОРМАЛИЗАЦИИ**

Общее назначение процесса нормализации заключается в следующем:

1. исключение некоторых типов избыточности;
1. устранение некоторых аномалий обновления;
1. разработка проекта базы данных, который является достаточно «хорошим» представлением реального мира, интуитивно понятен и может служить основой для последующего расширения;
1. упрощение процедуры описания необходимых ограничений целостности.

Рассмотрим последний пункт списка отдельно. Проблема состоит в том, что одни ограничения целостности определяют другие ограничения. Если ограничение **A** определяет ограничение **B**, то после приведения в действие ограничения **A** будет автоматически задействовано также ограничение **B** (для этого даже не потребуется объявлять ограничение **B** явным образом, за исключением случаев, когда это будет сделано в виде комментария). Например, ограничение для суммы зарплаты, которая должна быть выше 1 МРОТ, автоматически включает ограничение, согласно которому зарплата должна быть выше нуля.

Приведение к 5НФ представляет собой простой путь наложения некоторых важных и весьма распространенных ограничений. Главное – обеспечить поддержку уникальности потенциальных ключей, после чего все зависимости соединения (а также все многозначные и функциональные зависимости) будут реализованы СУБД автоматически, поскольку все они определяются потенциальными ключами.

Понятия зависимости и дальнейшей нормализации являются чисто семантическими, т.е. они связаны со смыслом данных, тогда как реляционная алгебра и реляционное исчисление, а также построенные на их основе языки наподобие SQL, наоборот, имеют дело со значениями данных и не требуют (и не могут требовать) выполнения нормализации выше первого уровня.

**ОБЩЕЕ НАЗНАЧЕНИЕ ПРОЦЕССА НОРМАЛИЗАЦИИ**

Рекомендации по выполнению дальнейшей нормализации должны рассматриваться, прежде всего, как некая упорядоченность, позволяющая разработчику базы данных (и, следовательно, ее пользователю) зафиксировать некую часть, пусть даже небольшую, семантики реального мира в простой и понятной форме.

Исходя из сказанного выше, необходимо отметить, что хотя идеи нормализации чрезвычайно полезны для проектирования баз данных, они вовсе не являются универсальным средством. Некоторые причины подобного положения дел:

- Нормализация действительно позволяет реализовать определенные ограничения целостности, однако на практике, помимо зависимостей соединения, функциональных и многозначных зависимостей, существуют и другие типы ограничений.
- Декомпозиция может быть неуникальной (как правило, имеется несколько способов приведения заданного набора переменных-отношений к 5НФ), однако существует очень мало критериев выбора наиболее предпочтительного варианта декомпозиции среди нескольких альтернативных.
- Преследование одновременно двух целей, т.е. приведение к НФБК и сохранение зависимостей, в некоторых случаях приводит к конфликтной ситуации.
- Процедура нормализации позволяет избавиться от избыточности за счет разбиения на проекции, однако не всякую избыточность можно устранить таким образом.

Рассмотрим, насколько актуальна нормализация сегодня, когда объемы доступных носителей внешней памяти непрерывно возрастают, стоимость их падает, а современные серверы реляционных баз данных способны автоматически поддерживать целостность баз данных.

**ОБЩЕЕ НАЗНАЧЕНИЕ ПРОЦЕССА НОРМАЛИЗАЦИИ**

Теория реляционных баз данных и методы их проектирования активно развивались с 70 годов прошлого века (XX века). Ситуация в области технологии аппаратуры и программного обеспечения тогда была совсем иной, чем сегодня, и хорошо нормализованные реляционные базы данных в значительной степени способствовали росту эффективности приложений. В то время реляционные базы преимущественно использовались в информационных системах оперативной обработки транзакций (**On-Line Transaction Processing – OLTP**). Характерные примеры таких систем это – банковские системы, системы резервирования билетов и мест в гостиницах. Системам категории OLTP свойственны частые обновления базы данных, поэтому аномалии обновлений, даже если их корректировка производится СУБД автоматически, могут заметно снижать эффективность приложения.

Подход к проектированию реляционных баз данных методом нормализации имеет свою нишу и сегодня. Как правило, любое предприятие использует хотя бы одно приложение баз данных – бухгалтерские, складские, кадровые системы. Это системы категории OLTP с частым обновлением данных и умеренными запросами к базе данных, не вызывающими соединений многих отношений. Для небольших компаний равно важны как эффективность информационных систем, так и стоимость используемых аппаратно-программных средств и стоимость обслуживания. Правильно спроектированные, хорошо нормализованные реляционные базы данных помогают избавиться от таких проблем.

Сегодня же все большее применения находят системы оперативной аналитической обработки (**On-Line Analytical Processing – OLAP**). В подобных системах, в частности, системах поддержки принятия решений, базы данных в основном используются для выборки данных, поэтому аномалиями обновлений можно пренебречь, а объем этих баз настолько огромен, что можно пренебречь и избыточностью хранения.

**ОБЩЕЕ НАЗНАЧЕНИЕ ПРОЦЕССА НОРМАЛИЗАЦИИ**

Однако системы категории OLAP достаточно дорогие, для их обслуживания и эксплуатации требуется высококвалифицированный персонал. Крупные развивающееся предприятия, как правило, приходят к использованию систем категории OLAP, например, в рамках некоторой разновидности систем поддержки принятия решений (**Decision Support System – DSS**). В базах данных таких систем обновления очень редки, а запросы могут иметь произвольную сложность, включая соединения многих отношений. Но, во-первых, технологически правильно для системы OLAP поддерживать отдельную базу данных (обычно подобные базы данных называют хранилищами данных – **DataWarehouse**), а во-вторых, основными источниками данных для построения таких хранилищ данных являются базы данных систем OLTP. Так что актуальность правильно спроектированных баз данных OLTP-систем не уменьшается, а постоянно возрастает.

Принципы нормализации применяются и для проектирования баз данных OLAP-приложений. При этом, возможно, окончательная схема такой базы данных будет не нормализована, чтобы обеспечить повышение эффективности выполнения запросов. Но чтобы получить правильную денормализованную схему, нужно сначала понять, как выглядит нормализованная.

Пока мы остаемся в мире реляционных баз данных, для правильного проектирования базы данных необходимо понимать принципы нормализации, воспринимая их не как догму, а как руководство к действию. Это относится не только к «ручному» проектированию реляционных баз данных, но и к их проектированию с применением семантических моделей данных и CASE-средств.

**ДРУГИЕ НОРМАЛЬНЫЕ ФОРМЫ**

Помимо уже описанных нормальных форм, существуют и другие нормальные формы. Теория нормализации и связанные с ней вопросы (эту область обычно называют теорией зависимостей) развились в значительную самостоятельную область знаний с обширной литературой. Рассмотрим еще три нормальные формы, не основанные на проекционно-соединительной теории нормализации.

**Доменно-ключевая нормальная форма (ДКНФ)**

Эта форма была предложена Фейджином. В отличие от рассмотренных выше нормальных форм, она не определяется в терминах функциональных зависимостей, многозначных зависимостей или зависимостей соединения. Вместо этого утверждается, что переменная-отношение  находится в ДКНФ тогда и только тогда, когда каждое наложенное на нее ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную-отношение  .

- Ограничение домена – это ограничение, предписывающее использование для определенного атрибута значений только из некоторого заданного домена.
- Ограничение ключа – это ограничение, утверждающее, что некоторый свойство или комбинация атрибутов представляет собой потенциальный ключ. Концептуально реализация ограничений, которые установлены для переменной-отношения, находящейся в ДКНФ, осуществляется очень просто, поскольку для этого достаточно реализовать поддержку ограничений домена и ключа, а все остальные ограничения будут приведены в действие автоматически. Обратим внимание, что под выражением «все остальные ограничения» подразумеваются не только функциональные и многозначные зависимости или зависимости соединения, а весь предикат данной переменной-отношения. Фейджин показал, что любая переменная-отношение, находящаяся в ДКНФ, находится в 5НФ (а значит, в 4НФ и т.д.). Однако не всегда можно привести переменную-отношение к ДКНФ или получить ответ на вопрос «Когда такое приведение может быть выполнено?».

**ДРУГИЕ НОРМАЛЬНЫЕ ФОРМЫ**

**Нормальная форма типа «выборка-объединение»**

Другим направлением в исследованиях нормализации является применение декомпозиции на основе операций, отличных от проекции. В данном сллучае, операцией декомпозиции является непересекающееся ограничение, а соответствующей операцией композиции – непересекающееся объединение. Таким образом, возможно создать «ограничительно-объединительную» теорию нормализации, аналогичную, но независимую от обсуждавшейся выше проекционно-соединительной теории нормализации.

Рассмотрим переменную-отношение  с данными о поставщиках. Согласно теории нормализации эта переменная-отношение находится в 5НФ и, следовательно, не характеризуется аномалиями и не нуждается в дальнейшем разбиении на проекции для устранения аномалий. Но зачем хранить сведения обо всех поставщиках в одной переменной-отношении? Может, было бы лучше разместить данные о поставщиках из Лондона в одном отношении (например, в отношении  ), из Парижа — в другом (например, в  ) и т.д.? Иначе говоря, может быть, стоило бы рассмотреть возможность декомпозиции на основе некоторого ограничения, а не на основе проекции? Классическая теория нормализации не может дать ответа на вопрос о том, лучше или хуже будет структура данных, полученная в результате такой декомпозиции.

**ДРУГИЕ НОРМАЛЬНЫЕ ФОРМЫ**

**Шестая нормальная форма**

Шестая нормальная форма введена К. Дейтом как обобщение пятой нормальной формы для хронологической базы данных (зависящей от времени). Переменная-отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная-отношения, которая находится в 6НФ, также находится и в 5НФ.

Например, переменная-отношения Работники не находится в 6НФ и может быть подвергнута декомпозиции на переменные отношения 

Должности работников и Домашние адреса работников.

**Должности работников**



|**Таб. №**|**Время**|**Должность**|
| - | - | - |
|6575|[01-01-2000:10-02-2003]|слесарь|
|6575|[16-06-2006:05-03-2009]|бригадир|
**Работники**



|**Таб. №**|**Время**|**Должность**|**Домашний адрес**|
| - | - | - | - |
|6575|[01-01-2000:10-02-2003]|слесарь|ул. Ленина, 10|
|6575|[11-02-2003:15-06-2006]|слесарь|ул. Советская, 22|
|6575|[16-06-2006:05-03-2009]|бригадир|ул. Советская, 22|
**Домашние адреса работников**



|**Таб. №**|**Время**|**Домашний адрес**|
| - | - | - |
|6575|[01-01-2000:10-02-2003]|ул. Ленина, 10|
|6575|[11-02-2003:15-06-2006]|ул. Советская, 22|


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)

https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
Высшая школа бизнеса Департамент бизнес-информатики![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.013.png)

**ТЕОРИЯ БАЗ ДАННЫХ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.003.png)**

# Лекция 5. Нормализация. Функциональные зависимости. 1NF, 2NF, 3NF

Москва, 2023
Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

Функциональная зависимость (functional dependence или functional dependency (FD) в англоязычной литературе) является связью типа «многие к одному» между множествами атрибутов внутри данной переменной-отношения.

Говоря о переменной-отношении, следует четко различать конкретное значение переменной-отношения в определенный момент времени (реализацию) и набор всех возможных значений, которые переменная-отношение может принимать в различные моменты времени. Говоря здесь о моментах времени, мы неявно рассматриваем процессы заполнения и последующей модификации переменной-отношения. 

Определение **функциональной зависимости** для набора всех возможных значений, которые может принимать переменная-отношение:

Пусть  есть переменная-отношение,  – множество атрибутов  ,  и  – произвольные подмножества множества  ,  = { ,…, },  = { ,…, }.

1 1 Обозначим через ( ) кортеж из проекции  на множество атрибутов  , а через ( ) – кортеж из проекции  на множество атрибутов  , ( ),

( ) состоят из элементов кортежа . функционально зависимо от  , ( → ), тогда и только тогда, когда для любого допустимого значения переменной-отношения  и любых двух кортежей и  из  из совпадения 1( ) и 2( ) следует совпадение 1( ) и 2( ). Другими словами, если 

два кортежа переменной-отношения  совпадают п1о зна2чению  ( ( ) = 2( )), то они также совпадают и по значению  ( 1( ) = ( )).

1 2

- ⇔ ( 1( ) = 2( )) ⇒ ( 1( ) = 2( )).

Опуская приведенные выше точные формулировки, говорят, что для любого допустимого значения переменной-отношения  каждое значение  связано с одним значением  .


Бекларян А.Л.![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.001.png)![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.002.png)

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**SCP** Отношение  удовлетворяет требованиям для ФЗ атрибутов {S#} и {CITY}, поскольку все кортежи отношения  с

|**S#**|**CITY**|**P#**|**QTY**|
| - | - | - | - |
|S1|London|P1|100|
|S1|London|P2|100|
|S2|Paris|P1|200|
|S2|Paris|P2|200|
|S3|Paris|P2|300|
|S4|London|P2|400|
|S4|London|P4|400|
|S4|London|P5|400|
одинаковыми значениями атрибута S# имеют одно и то же значение атрибута CITY: {S#} → {CITY}.

Можно полагать, что эта зависимость имеет место для любых возможных значений переменной-отношения  . Кроме того, для данной реализации отношения имеют место и другие зависимости:

- {S#, P#} → {QTY}
- {S#, P#} → {CITY}
- {S#, P#} → {CITY, QTY}
- {S#, P#} → {S#}
- {S#, P#} → {S#, P#, CITY, QTY}
- {S#} → {QTY}
- {QTY} → {S#}

Множество атрибутов в левой части записи функциональной зависимости иногда называют **детерминантом**, а множество атрибутов в правой части – **зависимой частью**. Когда множество содержит только один атрибут, оно называется **одноэлементным множеством**, скобки опускаются и символическая запись принимает более простой вид, например, S# → CITY. Некоторые из перечисленных ФЗ выполняются всегда, для набора всех возможных значений, которые может принимать переменная-отношение, другие же выполняются только в конкретной реализации переменной-отношения.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

Несколько безотносительных ко времени ФЗ, выполняющихся для переменной-отношения  :

- {S#, P#} → QTY
- {S#, P#} → CITY
- {S#, P#} → {CITY, QTY}
- {S#, P#} → S#
- {S#, P#} → {S#, P#, CITY, QTY}
- {S#} → CITY

Зависимости, которые выполняются для отношения, но не выполняются «всегда» для переменной-отношения  :

- S# → QTY
- QTY → S#

Иначе говоря, утверждение «число деталей для каждой поставки данного поставщика одинаково», истинно для конкретных значений, присутствующих в таблице, но ложно для всех возможных допустимых значений переменной-отношения  .

Нас будут интересовать только ФЗ, выполняющиеся для всех возможных значений данной переменной-отношения. Например, в случае переменной- отношения  ФЗ S# → CITY выполняется для всех возможных значений переменной-отношения  , поскольку в любой момент одному поставщику соответствует в точности один город. По этой причине любые два кортежа переменной-отношения  в один и тот же момент и с одним и тем же номером поставщика должны соответствовать одному и тому же городу. ФЗ, которые должны быть верны для любого допустимого значения переменной- отношения  , могут рассматриваться как **ограничения целостности** переменной-отношения  . Утверждение, что данная ФЗ выполняется «всегда» (т.е. для всех возможных значений  ), является ограничением целостности для переменной-отношения  , поскольку при этом накладываются определенные ограничения на все ее допустимые значения.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

Если  является потенциальным ключом переменной-отношения  , то все атрибуты  переменной-отношения  должны обязательно быть функционально зависимы от  . Если переменная-отношение  удовлетворяет ФЗ А → В и А не является потенциальным ключом, то  будет характеризоваться **избыточностью**. Наличие в переменной-отношении  ФЗ S# → CITY приведет к тому, что сведения о месте расположения поставщика в определенном городе повторятся.

Выявление зависимостей между атрибутами необходимо для выполнения проектирования БД методом **нормальных форм**. Полный набор функциональных зависимостей, выполняющихся для всех допустимых значений заданной переменной-отношения, может быть очень большим. Так как ФЗ являются ограничениями целостности, при каждом обновлении данных в базе СУБД вынуждена будет проверять соблюдение всех этих ограничений. Поэтому количество ФЗ надо уметь сокращать до некоторого разумного количества.

Следовательно, для каждого заданного множества функциональных зависимостей  желательно найти такое множество  , которое (в идеальной ситуации) было бы существенно меньше множества  и при этом каждая функциональная зависимость в множестве  могла бы быть заменена функциональной зависимостью из множества  . Если бы такое множество  было найдено, то СУБД достаточно было бы контролировать выполнение функциональных зависимостей из множества  , что автоматически подразумевало бы соблюдение всех функциональных зависимостей из множества  . Именно поэтому задача поиска подходящего множества  имеет большое практическое значение.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Тривиальные и нетривиальные зависимости**

Очевидным способом сокращения существующего набора функциональных зависимостей является исключение из него тривиальных зависимостей. Зависимость А → В называется **тривиальной**, если В ⊆ А (т.е. множество атрибутов А включает множество В или совпадает с ним). Тривиальная зависимость выполняется всегда. Тривиальная функциональная зависимость в переменной-отношении  – {S#, P#} → S#.

Тривиальные зависимости нельзя трактовать как ограничения целостности, с практической точки зрения они не представляют никакого интереса. Однако в формальной теории зависимостей необходимо учитывать все зависимости, как тривиальные, так и нетривиальные.

**Замыкание множества зависимостей**

Множество всех функциональных зависимостей, логически выводимых из множества функциональных зависимостей  , называется **замыканием множества функциональных зависимостей**  и обозначается  +. Например, из зависимости {S#, P#} → {CITY, QTY} можно логически вывести следующие функциональные зависимости: {S#, P#} → CITY, {S#, P#} → QTY.

Функциональная зависимость A → C называется **транзитивной**, если существует такой атрибут B, что имеются функциональные зависимости A → B и B

- C и отсутствует функциональная зависимость C → A.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Правила вывода**

Для решения задачи анализа ФЗ необходимо найти способ вычисления  + на основе  . Первая попытка решить эту проблему была предпринята Армстронгом, который предложил набор правил вывода новых ФЗ на основе заданных.

Пусть А, В и С – произвольные подмножества множества атрибутов заданной переменной-отношения R. Обозначим через АВ объединение множеств А и В (А∪В). Правила вывода имеют следующий вид:

1. Правило рефлексивности: если множество B является подмножеством множества А, то B функционально зависимо от A (если B ⊆ A, то А → В).
1. Правило пополнения: если (А → В ⇒ АС → ВС).
1. Правило транзитивности: если A → В и В → С, то А → С.

Каждое из этих трех правил может быть непосредственно доказано на основе определения функциональной зависимости. Можно доказать, что система правил вывода Армстронга полна и совершенна в том смысле, что для данного множества функциональные зависимости  любая ФЗ, потенциально выводимая из  , может быть получена на основе этих правил. Применение указанных правил не может привести к выводу ФЗ, которые не принадлежат множеству  +. Следовательно, эти правила можно использовать для получения замыкания  +. Поскольку эти правила по форме похожи на систему аксиом некоторой формальной теории, их также часто называют аксиомами Армстронга.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Правила вывода**

С целью упрощения задачи практического вычисления замыкания  + из трех приведенных выше правил можно вывести несколько дополнительных правил. Пусть D – некоторое произвольное подмножество множества атрибутов R.

4. Правило самодетерминированности: А → А.
4. Правило декомпозиции: если А → ВС, то А → В и А → С.
4. Правило объединения: если А → В и А → С, то А → ВС.
4. Правило композиции: если А → В и С → D, то АС → ВD.

В принципе, замыкание  + для заданного множества ФЗ  можно вычислить с помощью следующего алгоритма: «Применять правила из предыдущего раздела до тех пор, пока создание новых функциональных зависимостей не прекратится». Однако, на практике редко требуется вычислить замыкание само по себе, и поэтому только что упомянутый алгоритм вряд ли будет достаточно эффективным. Чаще требуется вычислить некоторое подмножество замыкания, а именно — подмножество, состоящее из всех ФЗ с некоторым заданным множеством  атрибутов, расположенных слева в записи {A} → {B,C}.

Пусть заданы отношение  , множество  атрибутов этого отношения (подмножество заголовка  , или составной атрибут  ) и некоторое множество ФЗ  , выполняемых для  . Множество всех атрибутов переменной-отношения  , которые ФЗ от  называются **замыканием**  + **множества  в пределах**  .

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Суперключ**

**Суперключ** переменной-отношения  – это множество атрибутов переменной-отношения  , которое в виде подмножества (необязательно собственного) содержит, по крайней мере, один потенциальный ключ.

Суперключи для данной переменной-отношения  – это такие подмножества  множества атрибутов переменной-отношения  , что ФЗ K → А будет истинна для каждого атрибута A переменной-отношения . Используя понятие замыкания множества можно сформулировать определение суперключа следующим образом:

Множество  является суперключом тогда и только тогда, когда замыкание  + для множества  в пределах заданного множества ФЗ является множеством абсолютно всех атрибутов переменной-отношения  .

Кроме того, множество  является потенциальным ключом тогда и только тогда, когда оно является неприводимым суперключом.

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Неприводимые множества зависимостей**

Пусть  и – два множества функциональных зависимостей. Если любая функциональная зависимость, которая выводится из множества зависимостей

1 2

, также выводится из множества зависимостей  ,т.е. если замыкание  + является подмножеством замыкания  +, то множество называется 

1 2 1 2 2

покрытием для множества . Это значит, что если СУБД обеспечит соблюдение ограничений, представленных зависимостями множества , то 

1 2 автоматически будут соблюдены и все ограничения, устанавливаемые зависимостями множества 1.

Если множество  является покрытием для множества , а множество одновременно является покрытием для множества (т.е. если + = +), то 

2 1 1 2 1 2 множества  и эквивалентны. Если множества  и эквивалентны, то соблюдение СУБД ограничений, представленных зависимостями множества

1 2 1 2

, автоматически обеспечит соблюдение ограничений, представленных зависимостями множества , и наоборот.

2 1

Множество ФЗ  называется неприводимым тогда и только тогда, когда оно обладает следующими свойствами.

1. Правая (зависимая) часть каждой ФЗ из множества  содержит только один атрибут (т.е. является одноэлементным множеством).
1. Левая часть (детерминант) каждой ФЗ из множества  является неприводимой, т.е. ни один атрибут из детерминанта не может быть опущен без изменения замыкания  + (без конвертирования множества  в некоторое иное множество, не эквивалентное множеству  ). В этом случае ФЗ называется неприводимой слева.
1. Ни одна ФЗ из множества  не может быть удалена из множества  без изменения его замыкания + (т.е. без конвертирования множества  в некоторое иное множество, не эквивалентное множеству  ).

В литературе подобное множество часто называется минимальным ( −).

**ФУНКЦИОНАЛЬНЫЕ ЗАВИСИМОСТИ (ФЗ)**

**Неприводимые множества зависимостей**

Не всегда обязательно иметь точную информацию о составе замыкания + для получения ответа на вопрос, изменится ли это замыкание при удалении из исходного множества какой-либо ФЗ.

**Утверждение**:

Для любого множества ФЗ существует по крайней мере одно эквивалентное множество, которое является неприводимым  −.

Множество ФЗ  , которое неприводимо и эквивалентно другому множеству функциональных зависимостей  , называется неприводимым покрытием множества  . Таким образом, с тем же успехом в системе вместо исходного множества ФЗ  может использоваться его неприводимое покрытие  (для вычисления неприводимого эквивалентного покрытия  необязательно вычислять замыкание  +). Однако необходимо отметить, что для заданного множества ФЗ не всегда существует уникальное неприводимое покрытие.

Отметим, что многое из вышесказанного можно обобщить на ограничения целостности. Следующие утверждения являются верными.

- Существуют тривиальные ограничения целостности.
- Существуют ограничения целостности, логически выводимые из других ограничений.
- Множество всех ограничений, логически выводимых из заданного множества, может рассматриваться как замыкание этого множества.

Выяснение вопроса, будет ли некоторое ограничение, принадлежать некоторому замканию (т.е. будет ли заданное ограничение выводится из некоторых данных ограничений), является очень важной практической задачей. Не менее важной практической задачей является поиск неприводимого покрытия для некоторого заданного множества установленных ограничений. Однако следует заметить, что благодаря наличию исчерпывающего и полного множества правил вывода, работать с функциональными зависимостями удобнее, чем с ограничениями целостности.

**НОРМАЛЬНЫЕ ФОРМЫ**

При проектировании базы данных решаются две основные проблемы.

- Проблема логического проектирования баз данных. Необходимо отобразить объекты предметной области в абстрактные объекты модели данных таким образом, чтобы это отображение не противоречило семантике предметной области и было, по возможности, лучшим (эффективным, удобным и т. д.).
- Проблема физического проектирования баз данных. Необходимо обеспечить эффективность выполнения запросов к базе данных, т. е. расположить данные во внешней памяти, создать дополнительные структуры (например, индексы и т.п.), учитывая особенности конкретной СУБД.

В случае реляционных баз данных трудно предложить какие-либо общие рецепты по части физического проектирования. Здесь слишком многое зависит от используемой СУБД. Поэтому ограничимся вопросами логического проектирования реляционных баз данных, которые существенны при использовании любой реляционной СУБД.

Будем считать, что проблема проектирования реляционной базы данных состоит в обоснованном принятии решений о том, из каких отношений должна состоять БД и какие атрибуты должны быть у этих отношений.

**НОРМАЛЬНЫЕ ФОРМЫ**

**Декомпозиция без потерь**

Рассмотрим подход к проектированию реляционных БД на основе нормализации. Процедура нормализации основывается на декомпозиции исходной переменной-отношения на другие переменные-отношения. Эта декомпозиция позволяет более эффективное выполнение операций обновления базы данных, поскольку сокращается число проверок и вспомогательных действий, поддерживающих целостность БД.

Процесс декомпозиции заключается в замене данной переменной-отношения некоторым набором ее проекций. Декомпозиция должна быть обратимой, т. е. должна имеется возможность собрать исходное отношение из декомпозированных отношений без потери информации (**декомпозиция без потерь**).

**S**



|**S#**|**STATUS**|**CITY**|
| - | - | - |
|S1|20|London|
|S2|30|Paris|
|S4|20|London|
|S5|30|Athens|
**НОРМАЛЬНЫЕ ФОРМЫ**

**Декомпозиция без потерь**

Рассмотрим два возможных варианта декомпозиции отношения  .

**а) б)**

**SSt SC SSt StC**



|**S#**|**STATUS**|
| - | - |
|S1|20|
|S2|30|
|S4|20|
|S5|30|

|**S#**|**CITY**|
| - | - |
|S1|London|
|S2|Paris|
|S4|London|
|S5|Athens|

|**S#**|**STATUS**|
| - | - |
|S1|20|
|S2|30|
|S4|20|
|S5|30|

|**STATUS**|**CITY**|
| - | - |
|20|London|
|30|Paris|
|20|London|
|30|Athens|
**НОРМАЛЬНЫЕ ФОРМЫ**

**Декомпозиция без потерь**

При проведении декомпозиции мы использовали операцию взятия проекции. Каждое из отношений  и  является проекцией исходного отношения  . В случае декомпозиции (а) информация не утрачивается, из отношений  и  можно узнать, что поставщик с номером S2 имеет статус 30 и находится в Париже, а поставщик с номером S5 имеет статус 30 и находится в Афинах.

Вторая декомпозиция (б) не дает возможности получить данные о местонахождении поставщиков S2 и S5: оба поставщика имеют одинаковый статус, и нельзя сказать какой из них находится в Париже, а какой в Афинах. Следовательно, эта декомпозиция приводит к потере информации.

В случае декомпозиции (а) отсутствие потери информации означает, что в результате естественного соединения отношений  и  мы гарантированно получим отношение, заголовок и тело которого совпадают с заголовком и телом отношения  . Это произойдет для любых допустимых (и согласованных) значений переменных отношений  ,  и  , поскольку у всех этих переменных атрибут S# является возможным ключом. В исходном отношении существует неприводимое множество функциональных зависимостей {S# → STATUS, S# → CITY}. В отношениях  и  также существуют функциональные зависимости S# → STATUS и S# → CITY соответственно.

В случае (б) при обратном соединении переменных-отношений  и  исходная переменная-отношение  получена не будет, т.е. будет утрачена информация. Это произойдет потому, что в исходном отношении нет функциональной зависимости STATUS → CITY (и в отношении  тоже).

«Обратимость» означает, что исходная переменная-отношение равна соединению ее проекций.

**НОРМАЛЬНЫЕ ФОРМЫ**

**Декомпозиция без потерь**

**Теорема Хита**

Пусть задано отношение  { , , } , где  ,  и  – множество атрибутов этого отношения. Если  удовлетворяет ФЗ A → B, тогда  равно соединению ее проекций PROJECT[A,B] и PROJECT[A,C].

- ( [ , ]) ( [ , ])

Определение. Атрибут  неприводимо (минимально) зависит от атрибута  , если выполняется неприводимая (минимальная) слева ФЗ A → B. Напомним, что ФЗ называется неприводимой слева, если левая часть (детерминант) каждой функциональной зависимости из множества является неприводимой, т.е. ни один атрибут из детерминанта не может быть опущен без изменения замыкания  +.

Например, в отношении СТУДЕНТ(StudentID, Name, Groupe, Speciality) выполняются ФЗ StudentID → Groupe и {StudentID, Name} → Groupe. Первая ФЗ является неприводимой (минимальной) слева, а вторая – нет. Поэтому Groupe неприводимо (минимально) зависит от StudentID, а для {StudentID, Name} свойство неприводимой зависимости не выполняется.

**НОРМАЛЬНЫЕ ФОРМЫ**

**Диаграммы функциональных зависимостей**

Пусть дана переменная отношение R и пусть к ней применимо некоторое неприводимое множество ФЗ  . Удобно представить это множество ФЗ в виде диаграммы функциональных зависимостей (диаграммы ФЗ).

На рисунке все стрелки начинаются с первичного ключа, поэтому на данной диаграмме никакие стрелки не могут быть удалены. В общем случае, в множество ФЗ могут входить ФЗ, в которых детерминантом является не потенциальный ключ отношения, т.е. ФЗ атрибутов не являются неприводимыми и стрелки на диаграмме не начинаются с возможного ключа. Процедуру нормализации можно неформально представить как процедуру удаления стрелок, не начинающихся с потенциальных ключей.

![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.048.png)

**НОРМАЛЬНЫЕ ФОРМЫ**

Процесс проектирования БД с использованием метода нормальных форм является итерационным и заключается в последовательном переводе отношений из первой нормальной формы в нормальные формы более высокого порядка по определенным правилам. Каждая следующая нормальная форма ограничивает определенный тип ФЗ, устраняет соответствующие аномалии при выполнении операций над отношениями БД и сохраняет свойства предшествующих нормальных форм.

Исходной точкой является представление предметной области в виде одного или нескольких отношений, и на каждом шаге проектирования производится некоторый набор схем отношений, обладающих «улучшенными» свойствами. Процесс проектирования представляет собой процесс нормализации схем отношений, причем каждая следующая нормальная форма обладает свойствами «лучшими», чем предыдущая.

Каждой нормальной форме соответствует определенный набор ограничений, и отношение находится в некоторой нормальной форме, если удовлетворяет свойственному ей набору ограничений. В теории реляционных баз данных обычно выделяется следующая последовательность нормальных форм:

- первая нормальная форма (1NF);
- вторая нормальная форма (2NF);
- третья нормальная форма (3NF);
- нормальная форма Бойса-Кодда (BCNF);
- четвертая нормальная форма (4NF);
- пятая нормальная форма, или нормальная форма проекции-соединения (5NF или PJ/NF);
- доменно-ключевая нормальная форма (DKNF);
- шестая нормальная форма (6NF).

Каждая последующая нормальная форма наследует свойства предыдущей и удовлетворяет некоторым дополнительным требованиям.

В основе процесса проектирования лежит метод нормализации, т. е. декомпозиции отношения, находящегося в предыдущей нормальной форме, на два или более отношений, которые удовлетворяют требованиям следующей нормальной формы.

**НОРМАЛЬНЫЕ ФОРМЫ**

**Первая нормальная форма**

Таблица находится в первой нормальной форме, если каждый её атрибут атомарен и все кортежи различны.

Выражение «атрибут атомарен» означает, что, в любом допустимом значении переменной-отношения каждый ее кортеж содержит только одно значение для каждого из атрибутов. Например, не соответствуют 1НФ таблицы, в полях которых могут храниться списки значений. Требование первой нормальной формы является базовым требованием классической реляционной модели данных. Будем считать, что исходный набор отношений уже соответствует этому требованию.

**Неприводимые ФЗ**

Множество ФЗ  называется неприводимым тогда и только тогда, когда оно обладает следующими свойствами.

1. Правая (зависимая) часть каждой ФЗ из множества  содержит только один атрибут (т.е. является одноэлементным множеством).
1. ФЗ является неприводимой слева.
1. Ни одна ФЗ из множества  не может быть удалена из множества  без изменения его замыкания  +.

**НОРМАЛЬНЫЕ ФОРМЫ**

Пусть задана переменная-отношение  c атрибутами {S#,STATUS, CITY, P#, QTY}. Пусть атрибуты {S#, P#} – первичный ключ. Переменная- отношение  находится в первой нормальной форме (1НФ), т.е. каждый атрибут атомарен.

**FIRST**



|**S#**|**STATUS**|**CITY**|**P#**|**QTY**|
| - | - | - | - | - |
|S1|20|London|P1|300|
|S1|20|London|P2|200|
|S1|20|London|P3|400|
|S1|20|London|P4|200|
|S1|20|London|P5|100|
|S1|20|London|P6|100|
|S2|10|Paris|P1|300|
|S2|10|Paris|P2|400|
|S3|10|Athens|P2|200|
|S4|20|London|P2|200|
|S4|20|London|P4|300|
|S4|20|London|P5|400|
![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.049.png)

**АНОМАЛИИ**

Во множество ФЗ отношения входят ФЗ, в которых детерминантом является не возможный ключ отношения. В диаграмме есть стрелки, начинающиеся не с {S#, P#}, т.е. некоторые ФЗ атрибутов от возможного ключа не являются неприводимыми. В таблице видно избыточное дублирование данных или избыточность данных. В каждом кортеже для поставщика с номером S1 атрибут CITY имеет значение London и атрибут STATUS имеет значение 20. Избыточность переменной отношения приводит к **аномалиям обновления**. Под аномалиями обновления понимаются трудности, с которыми приходится сталкиваться при выполнении операций добавления кортежей в отношение (INSERT), удаления кортежей (DELETE) и модификации кортежей (UPDATE). Рассмотрим сначала аномалии обновления, вызываемые наличием ФЗ S# → CITY. Эти аномалии связаны с избыточностью хранения значений атрибутов CITY и STATUS в каждом кортеже отношения.

**Добавление кортежей** (операция INSERT). Нельзя поместить в переменную-отношение  информацию о том, что некий поставщик находится в определенном городе, не указав сведений хотя бы об одной детали, им поставляемой.

**Удаление кортежей** (операция DELETE). Если из переменной-отношения  удалить данные о единственной поставке некоторого поставщика, то будет утеряна информация о данном поставщике вообще (т.е. информация о городе, где расположен поставщик и о его статусе).

**Модификация кортежей** (операция UPDATE). Название города для каждого поставщика повторяется несколько раз в переменной-отношения  , поэтому чтобы изменить значение CITY, например, у поставщика S1 вместо значения London записать значение Rome, необходимо найти в переменной- отношения  все кортежи, где значение атрибута S#S1 и заменить значение  London атрибута CITY на Rome. Если в переменной-отношении заменить не все значения London атрибута CITY на Rome, то база данных окажется в противоречивом состоянии.

Для преодоления этих трудностей можно произвести декомпозицию отношения  на два отношения – {S#, STATUS, CITY} и  {S#, P#, QTY}. На основании теоремы Хита эта декомпозиция является декомпозицией без потерь, поскольку в исходном отношении имелась ФЗ {S#, P#} → QTY.

**АНОМАЛИИ**

**SECOND SP**



|**S#**|**STATUS**|**CITY**|
| - | - | - |
|S1|20|London|
|S2|10|Paris|
|S3|10|Athens|
|S4|20|London|

|**S#**|**P#**|**QTY**|
| - | - | - |
|S1|P1|300|
|S1|P2|200|
|S1|P3|400|
|S1|P4|200|
|S1|P5|100|
|S1|P6|100|
|S2|P1|300|
|S2|P2|400|
|S3|P2|200|
|S4|P2|200|
|S4|P4|300|
|S4|P5|400|
![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.050.png)

**АНОМАЛИИ**

Измененная структура данных позволяет преодолеть все трудности, связанные с операциями вставки и с операциями обновления.

**Добавление кортежей** (операция INSERT).В отношение  можно поместить информацию о поставщиках, которые не производят поставок деталей в настоящее время. Например, добавить в отношение  информацию о поставщике с номером S5, находящимся в Афинах и имеющим статус 10.

**Удаление кортежей** (операция DELETE). Если кто-то из поставщиков, поставляющих только один тип деталей, прекращает их поставлять, кортеж о поставке можно убрать из отношения  . Информация о самом поставщике (номер, статус, город) не утратится. Уберем запись о поставке детали с номером P2 из переменный - отношения  .

**Модификация кортежей** (операция UPDATE). Если у какого-либо поставщика изменилось его месторасположение, достаточно модифицировать один кортеж в отношении  . Пусть поставщик S1 переместился из Лондона в Рим. Достаточно один раз изменить значение атрибута CITY в отношении 

.

**ВТОРАЯ НОРМАЛЬНАЯ ФОРМА**

Суть произведенной операции декомпозиции переменной-отношения  на переменные-отношения  и  состояла в исключении зависимостей, которые не являлись неприводимыми.

Переменная отношения находится во **второй нормальной форме** (2NF) тогда и только тогда, когда она находится в первой нормальной форме, и каждый неключевой атрибут неприводимо функционально зависит от первичного ключа.

Переменные-отношения  и  находятся в 2НФ, все неключевые атрибуты отношений минимально зависят от первичных ключей S# и {S#, P#} соответственно. Переменная-отношение  не находится в 2НФ (например, ФЗ {S#, P#} → CITY не является неприводимой). Любая переменная- отношение, находящаяся в 1НФ, но не находящаяся в 2НФ, может быть приведена к набору переменных отношений, находящихся в 2НФ. В результате декомпозиции мы получаем набор проекций исходной переменной отношения, естественное соединение значений которых воспроизводит значение исходной переменной отношения (т. е. это декомпозиция без потерь). Для переменных отношений  и  исходное отношение воспроизводится их естественным соединением по общему атрибуту S#.

Заметим, что допустимое значение переменной отношения  может содержать кортежи, информационное наполнение которых выходит за пределы допустимых значений переменной отношения  . Например, в теле отношения  может находиться кортеж с данными о поставщике с номером S5, который еще не участвует ни в одном поставке. Наличие такого кортежа не влияет на результат естественного соединения, тело которого все равно будет совпадать с телом допустимого значения переменной отношения  . 

Таким образом, первый этап процедуры нормализации состоит в создании проекций, которые позволяют исключить функциональные зависимости, не являющиеся неприводимыми.

**ВТОРАЯ НОРМАЛЬНАЯ ФОРМА**

Пусть дана переменная-отношение  , имеющая следующий вид:

R {A, B, C, D} PRIMARY KEY {A,B} (т.е. {A, B} → C, {A, B} → D)

Предполагается ФЗ A → D.

Процедура нормализации предусматривает замену переменной-отношения  следующими двумя проекциями  и  :

R1 {A, D} PRIMARY KEY {A}

R2 {A, B, C} PRIMARY KEY {A, B} FORIGN KEY {A} REFERENCES R1

Переменная-отношение  всегда может быть восстановлена посредством соединения переменных-отношений  и  по внешнему и соответствующему ему первичному ключу этих переменных-отношений.

**ТРАНЗИТИВНЫЕ ФЗ**

В произведенной декомпозиции переменной отношения  множество ФЗ переменной отношения  задано предельно просто – в единственной нетривиальной ФЗ детерминантом является возможный ключ {S#, P#}. При использовании этой переменной отношения какие-либо аномалии обновления не возникают. Однако выбранная структура переменной-отношения  может вызвать некоторые проблемы.

ФЗ переменной отношения  по-прежнему порождают некоторые аномалии обновления. Они вызываются наличием транзитивной ФЗ S# → STATUS, через ФЗ S# → CITY и CITY → STATUS. Эти аномалии связаны с избыточностью данных типа «город-статус», отвечающей ФЗ CITY → STATUS.

**Добавление кортежей** (операция INSERT). Нельзя поместить в базу данных сведения об определенном городе, обладающим некоторым статусом, до тех пор, пока в этом городе не появится конкретный поставщик (первичный ключ не может содержать неопределенные значения).

**Удаление кортежей** (операция DELETE). При удалении из переменной-отношения  кортежа с данными о единственном поставщике некоторого города, будет утеряна информация о том, каким статусом обладал данным город. Например, при удалении из переменной-отношения  кортежа (S3, 10, Athens) будет утрачена информация о статусе Афин.

**Модификация кортежей** (операция UPDATE). В переменной-отношения  информация о статусе города повторяется несколько раз, т.е. некоторая избыточность данных все еще остается. Для изменения статуса определенного города надо изменить значения атрибута STATUS во всех кортежах для всех поставщиков расположенных в данном городе.

**ТРАНЗИТИВНЫЕ ФЗ**

**SC**



|**S#**|**CITY**|
| - | - |
|S1|London|
|S2|Paris|
|S3|Athens|
|S4|London|
|S5|Athens|
Для преодоления этих трудностей произведем декомпозицию переменной-отношения  на две переменные-отношения – {S#, CITY} и  {CITY, STATUS}. По теореме Хита, это снова декомпозиция без потерь по причине наличия ФЗ S# → CITY и CITY → STATUS.

Данное преобразование обратимо, т.к. переменная-отношения  является естественным соединением значений отношений  и  . Такое изменение структуры переменных-отношений позволяет устранить проблемы, возникающие при выполнении операций обновления.

**Добавление кортежей**. Чтобы сохранить информацию о статусе нового города достаточно добавить 

соответствующий кортеж к отношению  .

**Удаление кортежей**. При увольнении единственного поставщика из данного города, удаляется соответствующий  **CS** кортеж из отношения  , данные о статусе города остаются в отношении  .

|**CITY**|**STATUS**|
| - | - |
|London|20|
|Paris|10|
|Athens|10|
**Модификация кортежей**. При изменении статуса города, изменяется значение атрибута STATUS ровно в одном 

кортеже отношения  .

Проблемы, возникающие при выполнении операций обновления, были связаны с наличием транзитивной функциональной зависимости. Наличие этой ФЗ означало, что атрибут STATUS характеризовал не сущность, которая идентифицировалась первичным ключом S# (номер поставщика), а сущность город CITY. Смешивание этих двух типов информации приводило к возникновению проблем.

**ТРЕТЬЯ НОРМАЛЬНАЯ ФОРМА**

Переменная отношения находится в третьей нормальной форме (3НФ) тогда и только тогда, когда она находится во второй нормальной форме, и каждый неключевой атрибут нетранзитивно функционально зависит от первичного ключа.

Переменные-отношения  и  находятся в 3НФ, все неключевые атрибуты нетранзитивно зависят от первичных ключей S# и CITY соответственно. Переменная-отношение не находится в 3НФ (ФЗ S# → STATUS является транзитивной). Любое отношение, находящееся в 2НФ, но не находящееся в 3НФ, может быть приведено к набору отношений, находящихся в 3НФ. При этом получается набор проекций исходного отношения, естественное соединение которых воспроизводит исходное отношение (т.е. это декомпозиция без потерь). Для отношений  и  исходное отношение 

воспроизводится их естественным соединением по общему атрибуту CITY.

Заметим, что допустимые значения отношения  могут содержать кортежи, информационное наполнение которых выходит за пределы тела отношения 

. Например, в теле отношения  может находиться кортеж с данными о городе Вена, в котором нет еще поставщиков деталей. Наличие такого 

кортежа не влияет на результат естественного соединения, который все равно будет являться допустимым значением отношения  .

**ТРЕТЬЯ НОРМАЛЬНАЯ ФОРМА**

Второй этап нормализации состоит в создании проекций для исключения транзитивных зависимостей. Пусть дана переменная-отношение  с атрибутами A, B, C. 

R {A, B, C} PRIMARY KEY {A}

Имеется ФЗ B → C

Процедура нормализации предусматривает декомпозицию этой переменной-отношения на переменные-отношения  и  .

R1 {B, C} PRIMARY KEY {B}

R2 {A, B} PRIMARY KEY {A} FORIGN KEY {B} REFERENCES R1

Переменная-отношение  всегда может быть восстановлена посредством соединения переменных-отношений  и  по внешнему и соответствующему ему первичному ключу этих переменных-отношений.

Уровень нормализации переменной-отношения определяется семантикой данных, а не их конкретными реализациями в некоторое время. Для того, чтобы однозначно определить находится ли данная переменная-отношение в 3НФ необходимо представлять себе сущность этих данных, т.е. существующие между ними зависимости.

**НЕЗАВИСИМЫЕ ПРОЕКЦИИ ОТНОШЕНИЙ**

В процессе нормализации часто возникает ситуация, когда переменная-отношение может быть подвергнута декомпозиции без потерь несколькими разными способами. Рассмотрим переменную-отношение  с ФЗ S# → CITY и CITY → STATUS, и транзитивной зависимостью S# → STATUS.

Аномалии обновления, сопровождающие переменную-отношение  можно преодолеть посредством ее декомпозиции с последующей заменой двумя проекциями в ЗНФ. Существуют три варианта декомпозиции:

Вариант 1. Декомпозиция **А** SC {S#, CITY} ![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.051.png)

CSt {CITY, STATUS} 

Вариант 2. Декомпозиция **В** SC {S#, CITY} 

SSt {S#, STATUS} 

Вариант 3. Декомпозиция **C** SSt {S#, STATUS} 

CSt {CITY, STATUS} 

**НЕЗАВИСИМЫЕ ПРОЕКЦИИ ОТНОШЕНИЙ**

Третий вариант декомпозиции переменной-отношения  не является допустимой декомпозицией, поскольку сопровождается потерей информации. Переменная-отношение  не является естественным соединением значений отношений и  по атрибуту STATUS. В переменной-отношении SECOND существует ФЗ CITY → STATUS, но нет ФЗ STATUS → CITY, т.е. одному значению атрибута STATUS могут соответствовать несколько значений атрибута CITY. Например, видно, что значение атрибута STATUS равное 10 соответствует двум городам.

Рассмотрим подробнее варианты декомпозиции **A** и **B**. Проекции  одинаковы и для варианта **А**, и для варианта **В**. Декомпозиция **A** выполняется без потери информации (мы подробно ее рассматривали при определении 3НФ). Декомпозиция **В** также выполняется без потери информации, и обе ее проекции находятся в ЗНФ. Однако декомпозиция **B** в отличие от декомпозиции **A**, не устраняет проблемы, связанные с обновлением отношения. Например, после выполнения декомпозиции **B** по-прежнему будет невозможно ввести информацию о том, что некоторый город имеет определенный статус, не указав конкретного поставщика из этого города.

В декомпозиции **А** обе проекции независимы одна от другой в том смысле, что обновления в каждой из них могут выполняться совершенно независимо. Если гарантируется, что выполняемые обновления будут допустимы, т.е. уникальность первичного ключа данной проекции не нарушается, то соединение этих двух проекций после обновления всегда будет иметь результатом допустимое значение переменной-отношения  . То есть при соединении не будут нарушаться ограничения, наложенные на функциональные зависимости в переменной-отношении  .

Однако в случае декомпозиции **В** вносимые в любую из двух проекций обновления должны тщательно контролироваться, чтобы исключить возможные нарушения функциональной зависимости CITY → STATUS. Нарушения могут иметь место, если два и более поставщиков находятся в одном и том же городе, в этом случае они должны иметь один статус. Например, если в декомпозиции **В** поставщик с номером S1 перемещается из Лондона в Париж. Иначе говоря, две проекции декомпозиции **В** не являются независимыми одна от другой.

**НЕЗАВИСИМЫЕ ПРОЕКЦИИ ОТНОШЕНИЙ**

Заметим, что зависимости, использованные для создания проекций в декомпозиции **А**, соответствуют сплошными стрелкам, тогда как одна из зависимостей, использованная для создания проекций в декомпозиции **В**, отмечена пунктирной стрелкой.

Основная проблема заключается в том, что в декомпозиции **В** ФЗ CITY → STATUS превращается в ограничение базы данных, охватывающее две переменные-отношения. В декомпозиции **А** ограничением базы данных является транзитивная зависимость S# → STATUS, которая автоматически выполняется в случае выполнения двух ограничений переменных-отношений: S# → CITY и CITY → STATUS. Реализовать эти ограничения очень просто, поскольку по сути они представляют собой требования поддержки уникальности значений первичных ключей в соответствующих переменных-отношениях.

Таким образом, концепция независимых проекций предоставляет критерий выбора одного из возможных вариантов декомпозиции. В частности, вариант декомпозиции, обеспечивающий независимость проекций в приведенном выше смысле, в общем случае предпочтительнее вариантов, в которых проекции будут зависимы.

**Теорема Риссанена**

Проекции  и  переменной-отношения  будут независимы тогда и только тогда, когда:

- каждая ФЗ в переменной-отношении  является логическим следствием ФЗ в ее проекциях  и  ;
- общие атрибуты проекций  и  образуют потенциальный ключ по хотя бы для одной из этих проекций.

**НЕЗАВИСИМЫЕ ПРОЕКЦИИ ОТНОШЕНИЙ**

Рассмотрим заданные выше декомпозиции **А** и **В**. В декомпозиции **А** обе проекции независимы, поскольку их общий атрибут CITY является первичным ключом для переменной-отношения  и каждая ФЗ переменной-отношения  либо представлена в одной из проекций, либо является логическим следствием других имеющихся в них ФЗ.

В декомпозиции **В**, наоборот, две составляющие ее проекции не являются независимыми, поскольку ФЗ CITY → STATUS не может быть выведена из ФЗ, существующих в этих проекциях, даже несмотря на то, что их общий атрибут S# является потенциальным ключом для обеих проекций.

Переменная-отношение называется **атомарной**, если она не может быть подвергнута декомпозиции с получением независимых проекций. Это не означает, что каждую неатомарную переменную-отношение следует непременно разбить на атомарные компоненты. Например, переменные-отношения и  из базы данных поставщиков и деталей не являются атомарными, однако дальнейшая их декомпозиция имела бы мало смысла. Переменная- отношение  , наоборот, является атомарной.

**Требование сохранения зависимостей**: нормализация всегда должна предусматривать декомпозицию переменных-отношений на независимые проекции.

**НЕЗАВИСИМЫЕ ПРОЕКЦИИ ОТНОШЕНИЙ**

**Замечания**

Пусть дана переменная-отношение  , которая после выполнения всех этапов нормализации заменяется множеством переменных-отношений 

, ,…, (проекциями переменной-отношения  ). Пусть также задано множество ФЗ  , имеющих место в исходной переменной-отношении  , и множество функциональных зависимостей  , ,…, , выполняющихся в переменных-отношениях  , ,…, . Каждая функциональная зависимость в множестве  будет иметь отношение только к атрибутам проекции  (где  = , , 3,…, ). В результате реализация ограничений (устанавливаемых существующими ФЗ) для любого данного множества  представляется достаточно простой задачей. Однако в действительности необходимо реализовать все ограничения, определяемые исходным множеством ФЗ  . Следовательно, целесообразно выбрать такой вариант декомпозиции исходной переменной-отношения на проекции  , ,…, , при котором совместный эффект от реализации ограничений для отдельных множеств  , ,…, будет эквивалентен реализации всех ограничений для исходного множества функциональных зависимостей  . Иначе говоря, декомпозиция должна выполняться с сохранением зависимостей.

Пусть  является объединением множеств зависимостей  , ,…, . В общем случае равенство  = не выполняется. Для декомпозиции с сохранением зависимостей достаточно, чтобы были равны замыкания множеств  и  ( + = ′+).

В общем случае не существует эффективного метода вычисления замыкания  + для заданного множества ФЗ, поэтому на практике вычисление и сравнение двух необходимых замыканий осуществить сложно.


` `![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.011.png)
https://www.hse.ru/staff/beklaryan E-mail: abeklaryan@hse.ru Адрес: Шаболовка ул., д.28/11, стр.4, каб. 1212![](Aspose.Words.82f9477f-53a4-4173-947b-c4d9d62a1269.012.png)
